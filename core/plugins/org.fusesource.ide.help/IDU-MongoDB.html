<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>MongoDB</title><link rel="stylesheet" type="text/css" href="eclipse_book.css"><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"><meta name="keywords" content="ESB, Apache ServiceMix, Open Source, open source, integration, OSGi, enterprise service bus, Apache ServiceMix documentation, Apache Karaf, Red Hat JBoss Fuse, Red Hat JBoss Fuse documentation"><meta name="keywords" content="ESB, Apache ServiceMix, Open Source, open source, integration, OSGi, enterprise service bus, Apache ServiceMix documentation, Apache Karaf, Red Hat JBoss Fuse, Red Hat JBoss Fuse documentation"><link rel="home" href="index.html" title="Red Hat JBoss Fuse Tooling for Eclipse"><link rel="up" href="IDU-Components.html" title="Apache Camel Component Reference"><link rel="prev" href="IDU-Mock.html" title="Mock"><link rel="next" href="IDU-MQTT.html" title="MQTT"><link rel="copyright" href="tmdisclaim.html" title="Trademark Disclaimer"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="IDU-MongoDB"></a>MongoDB</h1></div></div></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_CamelMongoDBcomponent"></a>Camel MongoDB component</h2></div></div></div><p><span class="bold"><strong>Available as of Camel 2.10</strong></span>
        </p><p>According to Wikipedia: "NoSQL is a movement promoting a loosely defined class of
            non-relational data stores that break with a long history of relational databases and
            ACID guarantees." NoSQL solutions have grown in popularity in the last few years, and
            major extremely-used sites and services such as Facebook, LinkedIn, Twitter, etc. are
            known to use them extensively to achieve scalability and agility.</p><p>Basically, NoSQL solutions differ from traditional RDBMS (Relational Database
            Management Systems) in that they don't use SQL as their query language and generally
            don't offer ACID-like transactional behaviour nor relational data. Instead, they are
            designed around the concept of flexible data structures and schemas (meaning that the
            traditional concept of a database table with a fixed schema is dropped), extreme
            scalability on commodity hardware and blazing-fast processing.</p><p>MongoDB is a very popular NoSQL solution and the <code class="code">camel-mongodb</code> component
            integrates Camel with MongoDB allowing you to interact with MongoDB collections both as
            a producer (performing operations on the collection) and as a consumer (consuming
            documents from a MongoDB collection).</p><p>MongoDB revolves around the concepts of documents (not as is office documents, but
            rather hierarchical data defined in JSON/BSON) and collections. This component page will
            assume you are familiar with them. Otherwise, visit <a class="link" href="http://www.mongodb.org/" target="_top">http://www.mongodb.org/</a>.</p><p>Maven users will need to add the following dependency to their
                <code class="literal">pom.xml</code> for this component:</p><pre class="programlisting">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.camel&lt;/groupId&gt;
    &lt;artifactId&gt;camel-mongodb&lt;/artifactId&gt;
    &lt;version&gt;2.18.1.redhat-000005&lt;/version&gt;
    &lt;!-- use the same version as your Camel core version --&gt;
&lt;/dependency&gt;</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_URIformat"></a>URI format</h2></div></div></div><p></p><pre class="programlisting">mongodb:connectionBean?database=databaseName&amp;collection=collectionName&amp;operation=operationName[&amp;moreOptions...]</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_Endpointoptions"></a>Endpoint options</h2></div></div></div><p>MongoDB endpoints support the following options, depending on whether they are acting
            like a Producer or as a Consumer (options vary based on the consumer type too).</p><p>
            
        </p><table id="d0e129721"><tr>
                <th> Name </th>
                <th> Default Value </th>
                <th> Description </th>
                <th> Producer </th>
                <th> Tailable Cursor Consumer </th>
            </tr><tr>
                <td><code class="literal">database</code>
                </td>
                <td> none </td>
                <td>
                    <span class="bold"><strong>Required.</strong></span> The name of the database to which
                    this endpoint will be bound. All operations will be executed against this
                    database unless dynamicity is enabled and
                        the&nbsp;<code class="literal">CamelMongoDbDatabase</code> header is set. </td>
                <td> (/) </td>
                <td> (/) </td>
            </tr><tr>
                <td><code class="literal">collection</code>
                </td>
                <td> none </td>
                <td>
                    <span class="bold"><strong>Required (Except for getDbStats and command operations).
                    </strong></span> The name of the collection (within the specified database) to which
                    this endpoint will be bound.&nbsp;ll operations will be executed against this
                    database unless dynamicity is enabled and
                        the&nbsp;<code class="literal">CamelMongoDbDatabase</code> header is set. </td>
                <td> (/) </td>
                <td> (/) </td>
            </tr><tr>
                <td><code class="literal">collectionIndex</code>
                </td>
                <td> none </td>
                <td><span class="bold"><strong>Camel 2.12:</strong></span> An optional <a class="link" href="http://docs.mongodb.org/manual/core/index-single/" target="_top">single field
                        index</a> or <a class="link" href="http://docs.mongodb.org/manual/core/index-compound/" target="_top">compound
                        index</a> to create when inserting new collections. </td>
                <td> (/) </td>
                <td></td>
            </tr><tr>
                <td><code class="literal">operation</code>
                </td>
                <td> none </td>
                <td>
                    <p>
                        <span class="bold"><strong>Required for producers.</strong></span> The id of the
                        operation this endpoint will execute. Pick from the following:</p>
                    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Query operations: <code class="literal">findById</code>,
                                    <code class="literal">findOneByQuery</code>, <code class="literal">findAll</code>,
                                    <code class="literal">count</code>
                            </p></li><li class="listitem"><p>Write operations: <code class="literal">insert</code>,
                                    <code class="literal">save</code>, <code class="literal">update</code>
                            </p></li><li class="listitem"><p>Delete operations: <code class="literal">remove</code>
                            </p></li><li class="listitem"><p>Other operations: <code class="literal">getDbStats</code>,
                                    <code class="literal">getColStats</code>, <code class="code">command</code></p></li></ul></div>
                </td>
                <td> (/) </td>
                <td></td>
            </tr><tr>
                <td><code class="literal">createCollection</code>
                </td>
                <td> true </td>
                <td> Determines whether the collection will be automatically created in the MongoDB
                    database during endpoint initialisation if it doesn't exist already. If this
                    option is <code class="literal">false</code> and the collection doesn't exist, an
                    initialisation exception will be thrown. </td>
                <td> (/) </td>
                <td></td>
            </tr><tr>
                <td><code class="literal">writeConcern</code></td>
                <td> none (driver's default) </td>
                <td> Set a <code class="literal">WriteConcern</code> on the operation out of MongoDB's
                    parameterised values. See <a class="link" href="http://api.mongodb.org/java/current/com/mongodb/WriteConcern.html#valueOf(java.lang.String)" target="_top">WriteConcern.valueOf(String)</a>. </td>
                <td> (/) </td>
                <td></td>
            </tr><tr>
                <td><code class="literal">writeConcernRef</code>
                </td>
                <td> none </td>
                <td> Sets a custom <code class="literal">WriteConcern</code> that exists in the Registry.
                    Specify the bean name. </td>
                <td> (/) </td>
                <td></td>
            </tr><tr>
                <td><code class="literal">readPreference</code>
                </td>
                <td> none </td>
                <td>
                    <p><span class="strong"><strong>Available as of Camel 2.12.4, 2.13.1 and
                        2.14.0:</strong></span> Sets a <a class="link" href="http://api.mongodb.org/java/current/com/mongodb/ReadPreference.html" target="_top">ReadPreference</a> on the connection. Accepted values are
                        those supported by the <a class="link" href="http://api.mongodb.org/java/current/com/mongodb/ReadPreference.html#valueOf%28java.lang.String%29" target="_top">ReadPreference#valueOf()</a> public API. Currently as of
                        MongoDB-Java-Driver version 2.12.0 the supported values are:
                        <code class="code">primary</code>, <code class="code">primaryPreferred</code>,
                        <code class="code">secondary</code>, <code class="code">secondaryPreferred</code> and
                        <code class="code">nearest</code>. See also the <a class="link" href="http://docs.mongodb.org/manual/core/read-preference/" target="_top">documentation</a> for more details about this option.</p>
                </td>
                <td> (/) </td>
                <td></td>
            </tr><tr>
                <td><code class="literal">dynamicity</code>
                </td>
                <td> false </td>
                <td> If set to true, the endpoint will inspect the
                        <code class="literal">CamelMongoDbDatabase</code> and
                        <code class="literal">CamelMongoDbCollection</code> headers of the incoming message,
                    and if any of them exists, the target collection and/or database will be
                    overridden for that particular operation. Set to false by default to avoid
                    triggering the lookup on every Exchange if the feature is not desired. </td>
                <td> (/) </td>
                <td></td>
            </tr><tr>
                <td><code class="literal">writeResultAsHeader</code>
                </td>
                <td> false </td>
                <td><span class="bold"><strong>Available as of Camel 2.10.3 and 2.11:</strong></span> In write
                    operations (save, update, insert, etc.), instead of replacing the body with the
                    WriteResult object returned by MongoDB, keep the input body untouched and place
                    the WriteResult in the <code class="literal">CamelMongoWriteResult</code> header (constant
                        <code class="literal">MongoDbConstants.WRITERESULT</code>). </td>
                <td> (/) </td>
                <td></td>
            </tr><tr>
                <td><code class="literal">outputType</code>
                </td>
                <td>
                    <p><code class="code">DBObjectList</code> for <code class="code">findAll</code></p>
                    <p><code class="code">DBObject</code> for all other operations</p>
                </td>
                <td>
                    <p><span class="bold"><strong>Camel 2.16:</strong></span> Convert the output of the
                        producer to the selected type: <code class="code">DBObjectList</code>,
                            <code class="code">DBObject</code> or <code class="code">DBCursor</code>.</p>
                    <p><code class="code">DBObjectList</code> or <code class="code">DBCursor</code> (may be useful to
                        stream the output) applies to <code class="code">findAll</code>. <code class="code">DBObject</code>
                        applies to all other operations.</p>
                </td>
                <td> (/) </td>
                <td></td>
            </tr><tr>
                <td><code class="literal">persistentTailTracking</code>
                </td>
                <td> false </td>
                <td> Enables or disables persistent tail tracking for Tailable Cursor consumers. See
                    below for more information. </td>
                <td></td>
                <td> (/) </td>
            </tr><tr>
                <td><code class="literal">persistentId</code>
                </td>
                <td> none </td>
                <td>
                    <span class="bold"><strong>Required if persistent tail tracking is
                        enabled.</strong></span> The id of this persistent tail tracker, to separate its
                    records from the rest on the tail-tracking collection. </td>
                <td></td>
                <td> (/) </td>
            </tr><tr>
                <td><code class="literal">tailTrackingIncreasingField</code>
                </td>
                <td> none </td>
                <td>
                    <span class="bold"><strong>Required if persistent tail tracking is
                        enabled.</strong></span> Correlation field in the incoming record which is of
                    increasing nature and will be used to position the tailing cursor every time it
                    is generated. The cursor will be (re)created with a query of type:
                    tailTrackIncreasingField &gt; lastValue (where lastValue is possibly recovered from
                    persistent tail tracking). Can be of type Integer, Date, String, etc. NOTE: No
                    support for dot notation at the current time, so the field should be at the top
                    level of the document. </td>
                <td></td>
                <td> (/) </td>
            </tr><tr>
                <td><code class="literal">cursorRegenerationDelay</code>
                </td>
                <td> 1000ms </td>
                <td> Establishes how long the endpoint will wait to regenerate the cursor after it
                    has been killed by the MongoDB server (normal behaviour). </td>
                <td></td>
                <td> (/) </td>
            </tr><tr>
                <td><code class="literal">tailTrackDb</code>
                </td>
                <td> same as endpoint's </td>
                <td> Database on which the persistent tail tracker will store its runtime
                    information. </td>
                <td></td>
                <td> (/) </td>
            </tr><tr>
                <td><code class="literal">tailTrackCollection</code>
                </td>
                <td> camelTailTracking </td>
                <td> Collection on which the persistent tail tracker will store its runtime
                    information. </td>
                <td></td>
                <td> (/) </td>
            </tr><tr>
                <td><code class="literal">tailTrackField</code>
                </td>
                <td> lastTrackingValue </td>
                <td> Field in which the persistent tail tracker will store the last tracked value. </td>
                <td></td>
                <td> (/) </td>
            </tr></table></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e130237"></a>Configuration of database in Spring XML</h2></div></div></div><p>The following Spring XML creates a bean defining the connection to a MongoDB
            instance.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;
    &lt;bean id="mongoBean" class="com.mongodb.Mongo"&gt;
        &lt;constructor-arg name="host" value="${mongodb.host}" /&gt;
        &lt;constructor-arg name="port" value="${mongodb.port}" /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre><p>In case you are using a 3.x MongoDB instance, which is new in Camel 2.18, you have to
            use the following bean:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;
    &lt;bean id="mongoBean" class="com.mongodb.MongoClient"&gt;
        &lt;constructor-arg name="host" value="${mongodb.host}" /&gt;
        &lt;constructor-arg name="port" value="${mongodb.port}" /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e130248"></a>Sample route</h2></div></div></div><p>The following route defined in Spring XML executes the operation dbStats on a
            collection.</p><pre class="programlisting">&lt;route&gt;
  &lt;from uri="direct:start" /&gt;
  &lt;!-- using bean 'mongoBean' defined above --&gt;
  &lt;to uri="mongodb:mongoBean?database=${mongodb.database}&amp;amp;collection=${mongodb.collection}&amp;amp;operation=getDbStats" /&gt;
  &lt;to uri="direct:result" /&gt;
&lt;/route&gt;</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_MongoDBoperationsproducerendpoints"></a>MongoDB operations - producer endpoints</h2></div></div></div><p></p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_Queryoperations"></a>Query operations</h2></div></div></div><p></p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_findById"></a>findById</h2></div></div></div><p></p><p>This operation retrieves only one element from the collection whose _id field matches
            the content of the IN message body. The incoming object can be anything that has an
            equivalent to a BSON type. See <a class="link" href="http://bsonspec.org/#/specification" target="_top">http://bsonspec.org/#/specification</a> and <a class="link" href="http://www.mongodb.org/display/DOCS/Java+Types" target="_top">http://www.mongodb.org/display/DOCS/Java+Types</a>.</p><pre class="programlisting">from("direct:findById")
    .to("mongodb:myDb?database=flights&amp;collection=tickets&amp;operation=findById")
    .to("mock:resultFindById");</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: Supports fields filter"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="imagesdb/tip.png"></td><th align="left">Supports fields filter</th></tr><tr><td align="left" valign="top"><p>This operation supports specifying a fields filter. See <a class="xref" href="IDU-MongoDB.html#IDU-MongoDB_HSH_Specifyingafieldsfilter" title="Specifying a fields filter">Specifying a fields filter</a>.</p></td></tr></table></div></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_findOneByQuery"></a>findOneByQuery</h2></div></div></div><p></p><p>Use this operation to retrieve just one element from the collection that matches a
            MongoDB query. <span class="bold"><strong>The query object is extracted from the IN message
                body</strong></span>, i.e. it should be of type <code class="literal">DBObject</code> or
            convertible to <code class="literal">DBObject</code>. It can be a JSON String or a Hashmap. See
                <a class="link" href="IDU-MongoDB.html#IDU-MongoDB_HSH_Typeconversions" title="Type conversions">Type conversions</a> for more
            info.</p><p>Example with no query (returns any object of the collection):</p><pre class="programlisting">from("direct:findOneByQuery")
    .to("mongodb:myDb?database=flights&amp;collection=tickets&amp;operation=findOneByQuery")
    .to("mock:resultFindOneByQuery");</pre><p>Example with a query (returns one matching result):</p><pre class="programlisting">from("direct:findOneByQuery")
    .setBody().constant("{ \"name\": \"Raul Kripalani\" }")
    .to("mongodb:myDb?database=flights&amp;collection=tickets&amp;operation=findOneByQuery")
    .to("mock:resultFindOneByQuery");</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: Supports fields filter"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="imagesdb/tip.png"></td><th align="left">Supports fields filter</th></tr><tr><td align="left" valign="top"><p>This operation supports specifying a fields filter. See <a class="xref" href="IDU-MongoDB.html#IDU-MongoDB_HSH_Specifyingafieldsfilter" title="Specifying a fields filter">Specifying a fields filter</a>.</p></td></tr></table></div></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_findAll"></a>findAll</h2></div></div></div><p>The <code class="literal">findAll</code> operation returns all documents matching a query. If
            your query is empty, all of the documents stored will match and be returned. <span class="bold"><strong>The query object is extracted from the IN message body</strong></span>, i.e.
            it should be of type <code class="literal">DBObject</code> or convertible to
                <code class="literal">DBObject</code>. It can be a JSON String or a Hashmap. See <a class="link" href="IDU-MongoDB.html#IDU-MongoDB_HSH_Typeconversions" title="Type conversions">Type conversions</a> for more
            info.</p><p>Example with no query (returns all documents in the collection):</p><pre class="programlisting">from("direct:findAll")
    .to("mongodb:myDb?database=flights&amp;collection=tickets&amp;operation=findAll")
    .to("mock:resultFindAll");</pre><p>Example with a query (returns all matching documents):</p><pre class="programlisting">from("direct:findAll")
    .setBody().constant("{ \"name\": \"Raul Kripalani\" }")
    .to("mongodb:myDb?database=flights&amp;collection=tickets&amp;operation=findAll")
    .to("mock:resultFindAll");</pre><p>Paging and efficient retrieval is supported via the following headers:</p><table id="d0e130352"><tr>
                <th> Header key </th>
                <th> Quick constant </th>
                <th> Description (extracted from MongoDB API doc) </th>
                <th> Expected type </th>
            </tr><tr>
                <td><code class="literal">CamelMongoDbNumToSkip</code>
                </td>
                <td><code class="literal">MongoDbConstants.NUM_TO_SKIP</code>
                </td>
                <td> Discards a given number of elements at the beginning of the cursor. </td>
                <td> int/Integer </td>
            </tr><tr>
                <td><code class="literal">CamelMongoDbLimit</code>
                </td>
                <td><code class="literal">MongoDbConstants.LIMIT</code>
                </td>
                <td> Limits the number of elements returned. </td>
                <td> int/Integer </td>
            </tr><tr>
                <td><code class="literal">CamelMongoDbBatchSize</code>
                </td>
                <td><code class="literal">MongoDbConstants.BATCH_SIZE</code>
                </td>
                <td> Limits the number of elements returned in one batch. A cursor typically fetches
                    a batch of result objects and store them locally. If batchSize is positive, it
                    represents the size of each batch of objects retrieved. It can be adjusted to
                    optimize performance and limit data transfer. If batchSize is negative, it will
                    limit of number objects returned, that fit within the max batch size limit
                    (usually 4MB), and cursor will be closed. For example if batchSize is -10, then
                    the server will return a maximum of 10 documents and as many as can fit in 4MB,
                    then close the cursor. Note that this feature is different from limit() in that
                    documents must fit within a maximum size, and it removes the need to send a
                    request to close the cursor server-side. The batch size can be changed even
                    after a cursor is iterated, in which case the setting will apply on the next
                    batch retrieval.</td>
                <td> int/Integer </td>
            </tr></table><p>You can also "stream" the documents returned from the server into your route by
            including outputType=DBCursor (Camel 2.16+) as an endpoint option which may prove
            simpler than setting the above headers. This hands your Exchange the DBCursor from the
            Mongo driver, just as if you were executing the findAll() within the Mongo shell,
            allowing your route to iterate over the results. By default and without this option,
            this component will load the documents from the driver's cursor into a List and return
            this to your route - which may result in a large number of in-memory objects. Remember,
            with a DBCursor do not ask for the number of documents matched - see the MongoDB
            documentation site for details.</p><p>Additionally, you can set a sortBy criteria by putting the relevant
                <code class="literal">DBObject</code> describing your sorting in the
                <code class="literal">CamelMongoDbSortBy</code> header, quick constant:
                <code class="literal">MongoDbConstants.SORT_BY</code>.</p><p>The <code class="literal">findAll</code> operation will also return the following OUT headers to
            enable you to iterate through result pages if you are using paging:</p><table id="d0e130439"><tr>
                <th> Header key </th>
                <th> Quick constant </th>
                <th> Description (extracted from MongoDB API doc) </th>
                <th> Data type </th>
            </tr><tr>
                <td><code class="literal">CamelMongoDbResultTotalSize</code>
                </td>
                <td><code class="literal">MongoDbConstants.RESULT_TOTAL_SIZE</code>
                </td>
                <td> Number of objects matching the query. This does not take limit/skip into
                    consideration. </td>
                <td> int/Integer </td>
            </tr><tr>
                <td><code class="literal">CamelMongoDbResultPageSize</code>
                </td>
                <td><code class="literal">MongoDbConstants.RESULT_PAGE_SIZE</code>
                </td>
                <td> Number of objects matching the query. This does not take limit/skip into
                    consideration. </td>
                <td> int/Integer </td>
            </tr></table><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: Supports fields filter"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="imagesdb/tip.png"></td><th align="left">Supports fields filter</th></tr><tr><td align="left" valign="top"><p>This operation supports specifying a fields filter. See <a class="xref" href="IDU-MongoDB.html#IDU-MongoDB_HSH_Specifyingafieldsfilter" title="Specifying a fields filter">Specifying a fields filter</a>.</p></td></tr></table></div></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e130497"></a>count</h2></div></div></div><p>Returns the total number of objects in a collection, returning a <code class="code">Long</code> as
            the <span class="emphasis"><em>Out</em></span> message body. The following example will count the number
            of records in the <code class="code">dynamicCollectionName</code> collection. Notice how dynamicity
            is enabled, and as a result, the operation will not run against the
                <code class="code">notableScientists</code> collection, but against the
                <code class="code">dynamicCollectionName</code> collection.</p><pre class="programlisting">// from("direct:count").to("mongodb:myDb?database=tickets&amp;collection=flights&amp;operation=count&amp;dynamicity=true");
Long result = template.requestBodyAndHeader("direct:count", "irrelevantBody", MongoDbConstants.COLLECTION, "dynamicCollectionName");
assertTrue("Result is not of type Long", result instanceof Long);</pre><p>From Camel 2.14 onwards you can provide a <code class="code">com.mongodb.DBObject</code> object in
            the message body as a query, and operation will return the amount of documents matching
            this criteria. </p><pre class="programlisting">DBObject query = ...
Long count = template.requestBodyAndHeader("direct:count", query, MongoDbConstants.COLLECTION, "dynamicCollectionName");</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_Specifyingafieldsfilter"></a>Specifying a fields filter</h2></div></div></div><p>Query operations will, by default, return the matching objects in their entirety (with
            all their fields). If your documents are large and you only require retrieving a subset
            of their fields, you can specify a field filter in all query operations, simply by
            setting the relevant <code class="literal">DBObject</code> (or type convertible to
                <code class="literal">DBObject</code>, such as a JSON String, Map, etc.) on the
                <code class="literal">CamelMongoDbFieldsFilter</code> header, constant shortcut:
                <code class="literal">MongoDbConstants.FIELDS_FILTER</code>. </p><p>Here is an example that uses MongoDB's BasicDBObjectBuilder to simplify the creation
            of DBObjects. It retrieves all fields except <code class="literal">_id</code> and
                <code class="literal">boringField</code>:</p><pre class="programlisting">// route: from("direct:findAll").to("mongodb:myDb?database=flights&amp;collection=tickets&amp;operation=findAll")
DBObject fieldFilter = BasicDBObjectBuilder.start().add("_id", 0).add("boringField", 0).get();
Object result = template.requestBodyAndHeader("direct:findAll", (Object) null, MongoDbConstants.FIELDS_FILTER, fieldFilter);</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_Createupdateoperations"></a>Create/update operations</h2></div></div></div><p></p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_insert"></a>insert</h2></div></div></div><p>Inserts an new object into the MongoDB collection, taken from the IN message body.
            Type conversion is attempted to turn it into <code class="literal">DBObject</code> or a
                <code class="literal">List</code>. Two modes are supported: single insert and multiple insert.
            For multiple insert, the endpoint will expect a List, Array or Collections of objects of
            any type, as long as they are - or can be converted to - <code class="literal">DBObject</code>.
            All objects are inserted at once. The endpoint will intelligently decide which backend
            operation to invoke (single or multiple insert) depending on the input.</p><p>Example:</p><pre class="programlisting">
from("direct:insert")
    .to("mongodb:myDb?database=flights&amp;collection=tickets&amp;operation=insert");
</pre><p>The operation will return a WriteResult, and depending on the
                <code class="literal">WriteConcern</code> or the value of the
                <code class="literal">invokeGetLastError</code> option, <code class="literal">getLastError()</code>
            would have been called already or not. If you want to access the ultimate result of the
            write operation, you need to retrieve the <code class="literal">CommandResult</code> by calling
                <code class="literal">getLastError()</code> or <code class="literal">getCachedLastError()</code> on the
                <code class="literal">WriteResult</code>. Then you can verify the result by calling
                <code class="literal">CommandResult.ok()</code>,
                <code class="literal">CommandResult.getErrorMessage()</code> and/or
                <code class="literal">CommandResult.getException()</code>.</p><p>Note that the new object's <code class="literal">_id</code> must be unique in the collection. If
            you don't specify the value, MongoDB will automatically generate one for you. But if you
            do specify it and it is not unique, the insert operation will fail (and for Camel to
            notice, you will need to enable invokeGetLastError or set a WriteConcern that waits for
            the write result). </p><p>This is not a limitation of the component, but it is how things work in MongoDB for
            higher throughput. If you are using a custom <code class="literal">_id</code>, you are expected to
            ensure at the application level that is unique (and this is a good practice too).</p><p>Since Camel 2.15: OID(s) of the inserted record(s) is stored in the message header
            under <code class="code">CamelMongoOid</code> key (<code class="code">MongoDbConstants.OID</code> constant). The
            value stored is <code class="code">org.bson.types.ObjectId</code> for single insert or
                <code class="code">java.util.List&lt;org.bson.types.ObjectId&gt;</code> if multiple records have
            been inserted.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_save"></a>save</h2></div></div></div><p>The save operation is equivalent to an <span class="emphasis"><em>upsert</em></span> (UPdate, inSERT)
            operation, where the record will be updated, and if it doesn't exist, it will be
            inserted, all in one atomic operation. MongoDB will perform the matching based on the
            _id field.</p><p>Beware that in case of an update, the object is replaced entirely and the usage of
                <a class="link" href="http://www.mongodb.org/display/DOCS/Updating#Updating-ModifierOperations" target="_top">MongoDB's $modifiers</a> is not permitted. Therefore, if you want to manipulate
            the object if it already exists, you have two options:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>perform a query to retrieve the entire object first along with all its fields
                    (may not be efficient), alter it inside Camel and then save it.</p></li><li class="listitem"><p>use the update operation with <a class="link" href="http://www.mongodb.org/display/DOCS/Updating#Updating-ModifierOperations" target="_top">$modifiers</a>, which will execute the update at the server-side
                    instead. You can enable the upsert flag, in which case if an insert is required,
                    MongoDB will apply the $modifiers to the filter query object and insert the
                    result.</p></li></ol></div><p>For example:</p><pre class="programlisting">
from("direct:insert")
    .to("mongodb:myDb?database=flights&amp;collection=tickets&amp;operation=save");
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_update"></a>update</h2></div></div></div><p>Update one or multiple records on the collection. Requires a List&lt;DBObject&gt; as the
            IN message body containing exactly 2 elements:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Element 1 (index 0) =&gt; filter query =&gt; determines what objects will be
                    affected, same as a typical query object</p></li><li class="listitem"><p>Element 2 (index 1) =&gt; update rules =&gt; how matched objects will be updated.
                    All <a class="link" href="http://www.mongodb.org/display/DOCS/Updating#Updating-ModifierOperations" target="_top">modifier operations</a> from MongoDB are supported.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Multiupdates"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="imagesdb/note.png"></td><th align="left">Multiupdates</th></tr><tr><td align="left" valign="top"><p>By default, MongoDB will only update 1 object even if multiple objects match the
                filter query. To instruct MongoDB to update <span class="bold"><strong>all</strong></span>
                matching records, set the <code class="literal">CamelMongoDbMultiUpdate</code> IN message
                header to <code class="literal">true</code>.</p></td></tr></table></div><p>A header with key <code class="literal">CamelMongoDbRecordsAffected</code> will be returned
                (<code class="literal">MongoDbConstants.RECORDS_AFFECTED</code> constant) with the number of
            records updated (copied from <code class="literal">WriteResult.getN()</code>).</p><p>Supports the following IN message headers:</p><table id="d0e130705"><tr>
                <th> Header key </th>
                <th> Quick constant </th>
                <th> Description (extracted from MongoDB API doc) </th>
                <th> Expected type </th>
            </tr><tr>
                <td><code class="literal">CamelMongoDbMultiUpdate</code>
                </td>
                <td><code class="literal">MongoDbConstants.MULTIUPDATE</code>
                </td>
                <td> If the update should be applied to all objects matching. See <a class="link" href="http://www.mongodb.org/display/DOCS/Atomic+Operations" target="_top">http://www.mongodb.org/display/DOCS/Atomic+Operations</a>
                </td>
                <td> boolean/Boolean </td>
            </tr><tr>
                <td><code class="literal">CamelMongoDbUpsert</code>
                </td>
                <td><code class="literal">MongoDbConstants.UPSERT</code>
                </td>
                <td> If the database should create the element if it does not exist </td>
                <td> boolean/Boolean </td>
            </tr></table><p>For example, the following will update <span class="bold"><strong>all</strong></span> records
            whose filterField field equals true by setting the value of the "scientist" field to
            "Darwin":</p><pre class="programlisting">
// route: from("direct:update").to("mongodb:myDb?database=science&amp;collection=notableScientists&amp;operation=update");
DBObject filterField = new BasicDBObject("filterField", true);
DBObject updateObj = new BasicDBObject("$set", new BasicDBObject("scientist", "Darwin"));
Object result = template.requestBodyAndHeader("direct:update", new Object[] {filterField, updateObj}, MongoDbConstants.MULTIUPDATE, true);
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_Deleteoperations"></a>Delete operations</h2></div></div></div><p></p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_remove"></a>remove</h2></div></div></div><p>Remove matching records from the collection. The IN message body will act as the
            removal filter query, and is expected to be of type <code class="literal">DBObject</code> or a
            type convertible to it. The following example will remove all objects whose field
            'conditionField' equals true, in the science database, notableScientists
            collection:</p><pre class="programlisting">
// route: from("direct:remove").to("mongodb:myDb?database=science&amp;collection=notableScientists&amp;operation=remove");
DBObject conditionField = new BasicDBObject("conditionField", true);
Object result = template.requestBody("direct:remove", conditionField);
</pre><p>A header with key <code class="literal">CamelMongoDbRecordsAffected</code> is returned
                (<code class="literal">MongoDbConstants.RECORDS_AFFECTED</code> constant) with type
                <code class="literal">int</code>, containing the number of records deleted (copied from
                <code class="literal">WriteResult.getN()</code>).</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_Otheroperations"></a>Other operations</h2></div></div></div><p></p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e130801"></a>aggregate</h2></div></div></div><p><span class="bold"><strong>Camel 2.14:</strong></span> Perform a aggregation with the given
            pipeline contained in the body. Aggregations could be long and heavy operations. Use
            with care.</p><pre class="programlisting">// route: from("direct:aggregate").to("mongodb:myDb?database=science&amp;collection=notableScientists&amp;operation=aggregate");
from("direct:aggregate")
    .setBody().constant("[{ $match : {$or : [{\"scientist\" : \"Darwin\"},{\"scientist\" : \"Einstein\"}]}},{ $group: { _id: \"$scientist\", count: { $sum: 1 }} } ]")
    .to("mongodb:myDb?database=science&amp;collection=notableScientists&amp;operation=aggregate")
    .to("mock:resultAggregate");</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_getDbStats"></a>getDbStats</h2></div></div></div><p>Equivalent of running the <code class="literal">db.stats()</code> command in the MongoDB shell,
            which displays useful statistic figures about the database. For example:</p><pre class="programlisting">&gt; db.stats();
{
	"db" : "test",
	"collections" : 7,
	"objects" : 719,
	"avgObjSize" : 59.73296244784423,
	"dataSize" : 42948,
	"storageSize" : 1000058880,
	"numExtents" : 9,
	"indexes" : 4,
	"indexSize" : 32704,
	"fileSize" : 1275068416,
	"nsSizeMB" : 16,
	"ok" : 1
}</pre><p>Usage example:</p><pre class="programlisting">// from("direct:getDbStats").to("mongodb:myDb?database=flights&amp;collection=tickets&amp;operation=getDbStats");
Object result = template.requestBody("direct:getDbStats", "irrelevantBody");
assertTrue("Result is not of type DBObject", result instanceof DBObject);</pre><p>The operation will return a data structure similar to the one displayed in the shell,
            in the form of a <code class="literal">DBObject</code> in the OUT message body. </p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_getColStats"></a>getColStats</h2></div></div></div><p>Equivalent of running the <code class="literal">db.collection.stats()</code> command in the
            MongoDB shell, which displays useful statistic figures about the collection. For
            example:</p><pre class="programlisting">
&gt; db.camelTest.stats();
{
	"ns" : "test.camelTest",
	"count" : 100,
	"size" : 5792,
	"avgObjSize" : 57.92,
	"storageSize" : 20480,
	"numExtents" : 2,
	"nindexes" : 1,
	"lastExtentSize" : 16384,
	"paddingFactor" : 1,
	"flags" : 1,
	"totalIndexSize" : 8176,
	"indexSizes" : {
		"_id_" : 8176
	},
	"ok" : 1
}
</pre><p>Usage example:</p><pre class="programlisting">
// from("direct:getColStats").to("mongodb:myDb?database=flights&amp;collection=tickets&amp;operation=getColStats");
Object result = template.requestBody("direct:getColStats", "irrelevantBody");
assertTrue("Result is not of type DBObject", result instanceof DBObject);
</pre><p>The operation will return a data structure similar to the one displayed in the shell,
            in the form of a <code class="literal">DBObject</code> in the OUT message body. </p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e130850"></a>command</h2></div></div></div><p><span class="bold"><strong>Camel 2.15:</strong></span> Run the body as a command on database.
            Useful for admin operation as getting host informations, replication or sharding status.
            Collection parameter is not use for this operation.</p><pre class="programlisting">// route: from("command").to("mongodb:myDb?database=science&amp;operation=command");
DBObject commandBody = new BasicDBObject("hostInfo", "1");
Object result = template.requestBody("direct:command", commandBody);</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_Dynamicoperations"></a>Dynamic operations</h2></div></div></div><p>An Exchange can override the endpoint's fixed operation by setting the
                <code class="literal">CamelMongoDbOperation</code> header, defined by the
                <code class="literal">MongoDbConstants.OPERATION_HEADER</code> constant. The values supported
            are determined by the MongoDbOperation enumeration and match the accepted values for the
                <code class="literal">operation</code> parameter on the endpoint URI.</p><p>For example:</p><pre class="programlisting">// from("direct:insert").to("mongodb:myDb?database=flights&amp;collection=tickets&amp;operation=insert");
Object result = template.requestBodyAndHeader("direct:insert", "irrelevantBody", MongoDbConstants.OPERATION_HEADER, "count");
assertTrue("Result is not of type Long", result instanceof Long);</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_TailableCursorConsumer"></a>Tailable Cursor Consumer</h2></div></div></div><p>MongoDB offers a mechanism to instantaneously consume ongoing data from a collection,
            by keeping the cursor open just like the <code class="literal">tail -f</code> command of *nix
            systems. This mechanism is significantly more efficient than a scheduled poll, due to
            the fact that the server pushes new data to the client as it becomes available, rather
            than making the client ping back at scheduled intervals to fetch new data. It also
            reduces otherwise redundant network traffic.</p><p>There is only one requisite to use tailable cursors: the collection must be a "capped
            collection", meaning that it will only hold N objects, and when the limit is reached,
            MongoDB flushes old objects in the same order they were originally inserted. For more
            information, please refer to: <a class="link" href="http://www.mongodb.org/display/DOCS/Tailable+Cursors" target="_top">http://www.mongodb.org/display/DOCS/Tailable+Cursors</a>. </p><p>The Camel MongoDB component implements a tailable cursor consumer, making this feature
            available for you to use in your Camel routes. As new objects are inserted, MongoDB will
            push them as DBObjects in natural order to your tailable cursor consumer, who will
            transform them to an Exchange and will trigger your route logic.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_Howthetailablecursorconsumerworks"></a>How the tailable cursor consumer works</h2></div></div></div><p>To turn a cursor into a tailable cursor, a few special flags are to be signalled to
            MongoDB when first generating the cursor. Once created, the cursor will then stay open
            and will block upon calling the <code class="literal">DBCursor.next()</code> method until new data
            arrives. However, the MongoDB server reserves itself the right to kill your cursor if
            new data doesn't appear after an indeterminate period. If you are interested to continue
            consuming new data, you have to regenerate the cursor. And to do so, you will have to
            remember the position where you left off or else you will start consuming from the top
            again. </p><p>The Camel MongoDB tailable cursor consumer takes care of all these tasks for you. You
            will just need to provide the key to some field in your data of increasing nature, which
            will act as a marker to position your cursor every time it is regenerated, e.g. a
            timestamp, a sequential ID, etc. It can be of any datatype supported by MongoDB. Date,
            Strings and Integers are found to work well. We call this mechanism "tail tracking" in
            the context of this component.</p><p>The consumer will remember the last value of this field and whenever the cursor is to
            be regenerated, it will run the query with a filter like: <code class="literal">increasingField &gt;
                lastValue</code>, so that only unread data is consumed.</p><p><span class="bold"><strong>Setting the increasing field:</strong></span> Set the key of the
            increasing field on the endpoint URI <code class="literal">tailTrackingIncreasingField</code>
            option. In Camel 2.10, it must be a top-level field in your data, as nested navigation
            for this field is not yet supported. That is, the "timestamp" field is okay, but
            "nested.timestamp" will not work. Please open a ticket in the Camel JIRA if you do
            require support for nested increasing fields.</p><p><span class="bold"><strong>Cursor regeneration delay:</strong></span> One thing to note is that
            if new data is not already available upon initialisation, MongoDB will kill the cursor
            instantly. Since we don't want to overwhelm the server in this case, a
                <code class="literal">cursorRegenerationDelay</code> option has been introduced (with a
            default value of 1000ms.), which you can modify to suit your needs.</p><p>An example:</p><pre class="programlisting">from("mongodb:myDb?database=flights&amp;collection=cancellations&amp;tailTrackIncreasingField=departureTime")
    .id("tailableCursorConsumer1")
    .autoStartup(false)
    .to("mock:test");</pre><p>The above route will consume from the "flights.cancellations" capped collection, using
            "departureTime" as the increasing field, with a default regeneration cursor delay of
            1000ms.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_Persistenttailtracking"></a>Persistent tail tracking</h2></div></div></div><p>Standard tail tracking is volatile and the last value is only kept in memory. However,
            in practice you will need to restart your Camel container every now and then, but your
            last value would then be lost and your tailable cursor consumer would start consuming
            from the top again, very likely sending duplicate records into your route.</p><p>To overcome this situation, you can enable the <span class="bold"><strong>persistent tail
                tracking</strong></span> feature to keep track of the last consumed increasing value in a
            special collection inside your MongoDB database too. When the consumer initialises
            again, it will restore the last tracked value and continue as if nothing
            happened.</p><p>The last read value is persisted on two occasions: every time the cursor is
            regenerated and when the consumer shuts down. We may consider persisting at regular
            intervals too in the future (flush every 5 seconds) for added robustness if the demand
            is there. To request this feature, please open a ticket in the Camel JIRA.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_Enablingpersistenttailtracking"></a>Enabling persistent tail tracking</h2></div></div></div><p>To enable this function, set at least the following options on the endpoint
            URI:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">persistentTailTracking</code> option to <code class="literal">true</code>
                </p></li><li class="listitem"><p><code class="literal">persistentId</code> option to a unique identifier for this
                    consumer, so that the same collection can be reused across many consumers</p></li></ul></div><p>Additionally, you can set the <code class="literal">tailTrackDb</code>,
                <code class="literal">tailTrackCollection</code> and <code class="literal">tailTrackField</code> options
            to customise where the runtime information will be stored. Refer to the endpoint options
            table at the top of this page for descriptions of each option.</p><p>For example, the following route will consume from the "flights.cancellations" capped
            collection, using "departureTime" as the increasing field, with a default regeneration
            cursor delay of 1000ms, with persistent tail tracking turned on, and persisting under
            the "cancellationsTracker" id on the "flights.camelTailTracking", storing the last
            processed value under the "lastTrackingValue" field
                (<code class="literal">camelTailTracking</code> and <code class="literal">lastTrackingValue</code> are
            defaults).</p><pre class="programlisting">from("mongodb:myDb?database=flights&amp;collection=cancellations&amp;tailTrackIncreasingField=departureTime&amp;persistentTailTracking=true" + 
     "&amp;persistentId=cancellationsTracker")
	.id("tailableCursorConsumer2")
	.autoStartup(false)
	.to("mock:test");</pre><p>Below is another example identical to the one above, but where the persistent tail
            tracking runtime information will be stored under the "trackers.camelTrackers"
            collection, in the "lastProcessedDepartureTime" field:</p><pre class="programlisting">from("mongodb:myDb?database=flights&amp;collection=cancellations&amp;tailTrackIncreasingField=departureTime&amp;persistentTailTracking=true" + 
     "&amp;persistentId=cancellationsTracker"&amp;tailTrackDb=trackers&amp;tailTrackCollection=camelTrackers" + 
     "&amp;tailTrackField=lastProcessedDepartureTime")
	.id("tailableCursorConsumer3")
	.autoStartup(false)
	.to("mock:test");</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_Typeconversions"></a>Type conversions</h2></div></div></div><p>The <code class="literal">MongoDbBasicConverters</code> type converter included with the
            camel-mongodb component provides the following conversions:</p><table id="d0e130997"><tr>
                <th> Name </th>
                <th> From type </th>
                <th> To type </th>
                <th> How? </th>
            </tr><tr>
                <td> fromMapToDBObject </td>
                <td><code class="literal">Map</code>
                </td>
                <td><code class="literal">DBObject</code>
                </td>
                <td> constructs a new <code class="literal">BasicDBObject</code> via the <code class="literal">new
                        BasicDBObject(Map m)</code> constructor </td>
            </tr><tr>
                <td> fromBasicDBObjectToMap </td>
                <td><code class="literal">BasicDBObject</code>
                </td>
                <td><code class="literal">Map</code>
                </td>
                <td><code class="literal">BasicDBObject</code> already implements <code class="literal">Map</code>
                </td>
            </tr><tr>
                <td> fromStringToDBObject </td>
                <td><code class="literal">String</code>
                </td>
                <td><code class="literal">DBObject</code>
                </td>
                <td> uses <code class="literal">com.mongodb.util.JSON.parse(String s)</code>
                </td>
            </tr><tr>
                <td> fromAnyObjectToDBObject </td>
                <td><code class="literal">Object</code>&nbsp;</td>
                <td><code class="literal">DBObject</code>&nbsp;</td>
                <td> uses the <a class="link" href="http://jackson.codehaus.org/" target="_top">Jackson library</a> to
                    convert the object to a <code class="literal">Map</code>, which is in turn used to
                    initialise a new <code class="literal">BasicDBObject</code>
                </td>
            </tr></table><p>This type converter is auto-discovered, so you don't need to configure anything
            manually.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-MongoDB_HSH_Seealso"></a>See also</h2></div></div></div><p></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p></p><p>
                    <a class="link" href="http://www.mongodb.org/" target="_top">MongoDB website</a>
                </p></li><li class="listitem"><p></p><p>
                    <a class="link" href="http://en.wikipedia.org/wiki/NoSQL" target="_top">NoSQL Wikipedia
                        article</a>
                </p></li><li class="listitem"><p></p><p>
                    <a class="link" href="http://api.mongodb.org/java/current/" target="_top">MongoDB Java driver API
                        docs - current version</a>
                </p></li><li class="listitem"><p></p><p>
                    <a class="link" href="http://svn.apache.org/viewvc/camel/trunk/components/camel-mongodb/src/test/" target="_top">Unit tests</a> for more examples of usage</p></li></ul></div></div></div></body></html>