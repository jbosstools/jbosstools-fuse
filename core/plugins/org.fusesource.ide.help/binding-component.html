<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Binding Component (deprecated)</title><link rel="stylesheet" type="text/css" href="eclipse_book.css"><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"><link rel="home" href="index.html" title="Red Hat Fuse Tooling"><link rel="up" href="IDU-Components.html" title="Part&nbsp;V.&nbsp;Apache Camel Component Reference"><link rel="prev" href="bean-validator-component.html" title="Bean Validator Component"><link rel="next" href="bindy-dataformat.html" title="Bindy DataFormat"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="binding-component"></a>Binding Component (deprecated)</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="binding-component.html#_options_9">Options</a></span></dt><dt><span class="section"><a href="binding-component.html#_using_bindings">Using Bindings</a></span></dt><dt><span class="section"><a href="binding-component.html#_using_the_binding_uri">Using the binding URI</a></span></dt><dt><span class="section"><a href="binding-component.html#_using_a_bindingcomponent">Using a BindingComponent</a></span></dt><dt><span class="section"><a href="binding-component.html#_when_to_use_bindings">When to use Bindings</a></span></dt></dl></div><p><span class="strong"><strong>Available as of Camel version 2.11</strong></span></p><p>In Camel terms a <span class="emphasis"><em>binding</em></span> is a way of wrapping an
Endpoint in a contract; such as a
Data Format, a <a class="link" href="content-enricher.html" target="_top">Content
Enricher</a> or validation step. Bindings are completely optional and you
can choose to use them on any camel endpoint.</p><p>Bindings are inspired by the work of
<a class="link" href="http://www.jboss.org/switchyard" target="_top">SwitchYard project</a> adding service
contracts to various technologies like Camel and many others. But rather
than the SwitchYard approach of wrapping Camel in SCA, <span class="emphasis"><em>Camel Bindings</em></span>
provide a way of wrapping Camel endpoints with contracts inside the
Camel framework itself; so you can use them easily inside any Camel
route.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_options_9"></a>Options</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="binding-component.html#_path_parameters_2_parameters_3">Path Parameters (2 parameters):</a></span></dt><dt><span class="section"><a href="binding-component.html#_query_parameters_4_parameters">Query Parameters (4 parameters):</a></span></dt></dl></div><p>The Binding component has no options.</p><p>The Binding endpoint is configured using URI syntax:</p><pre class="screen">binding:bindingName:delegateUri</pre><p>with the following path and query parameters:</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_path_parameters_2_parameters_3"></a>Path Parameters (2 parameters):</h3></div></div></div><div class="informaltable"><table border="1" width="100%"><colgroup><col width="19%" class="col_1"><col width="51%" class="col_2"><col width="10%" class="col_3"><col width="20%" class="col_4"></colgroup><thead><tr><th align="left" valign="top">Name</th><th align="left" valign="top">Description</th><th align="center" valign="top">Default</th><th align="left" valign="top">Type</th></tr></thead><tbody><tr><td align="left" valign="top"><p><span class="strong"><strong>bindingName</strong></span></p></td><td align="left" valign="top"><p><span class="strong"><strong>Required</strong></span> Name of the binding to lookup in the Camel registry.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>delegateUri</strong></span></p></td><td align="left" valign="top"><p><span class="strong"><strong>Required</strong></span> Uri of the delegate endpoint.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_query_parameters_4_parameters"></a>Query Parameters (4 parameters):</h3></div></div></div><div class="informaltable"><table border="1" width="100%"><colgroup><col width="19%" class="col_1"><col width="51%" class="col_2"><col width="10%" class="col_3"><col width="20%" class="col_4"></colgroup><thead><tr><th align="left" valign="top">Name</th><th align="left" valign="top">Description</th><th align="center" valign="top">Default</th><th align="left" valign="top">Type</th></tr></thead><tbody><tr><td align="left" valign="top"><p><span class="strong"><strong>bridgeErrorHandler</strong></span> (consumer)</p></td><td align="left" valign="top"><p>Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN/ERROR level and ignored.</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>exceptionHandler</strong></span> (consumer)</p></td><td align="left" valign="top"><p>To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this options is not in use. By default the consumer will deal with exceptions, that will be logged at WARN/ERROR level and ignored.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>ExceptionHandler</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>exchangePattern</strong></span> (consumer)</p></td><td align="left" valign="top"><p>Sets the default exchange pattern when creating an exchange.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>ExchangePattern</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>synchronous</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_using_bindings"></a>Using Bindings</h2></div></div></div><p>A Binding is currently a bean which defines the contract (though we&#8217;ll
hopefully add bindings to the Camel DSL).</p><p>There are a few approaches to defining a bound endpoint (i.e. an
endpoint bound with a Binding).</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_using_the_binding_uri"></a>Using the binding URI</h2></div></div></div><p>You can prefix any endpoint URI with <span class="strong"><strong>binding:nameOfBinding:</strong></span> where
<span class="emphasis"><em>nameOfBinding</em></span> is the name of the Binding bean in your registry.</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"binding:jaxb:activemq:myQueue"</em></strong>).to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"binding:jaxb:activemq:anotherQueue"</em></strong>)</pre><p>Here we are using the "jaxb" binding which may, for example, use the
JAXB Data Format to marshal and unmarshal
messages.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_using_a_bindingcomponent"></a>Using a BindingComponent</h2></div></div></div><p>There is a Component called BindingComponent which
can be configured in your Registry by dependency
injection which allows the creation of endpoints which are already bound
to some binding.</p><p>For example if you registered a new component called "jsonmq" in your
registry using code like this</p><pre class="programlisting">JacksonDataFormat format = <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">new</strong> JacksonDataFormat(MyBean.<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">class</strong>);
context.bind(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"jsonmq"</em></strong>, <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">new</strong> BindingComponent(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">new</strong> DataFormatBinding(format), <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"activemq:foo."</em></strong>));</pre><p>Then you could use the endpoint as if it were any other endpoint.</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"jsonmq:myQueue"</em></strong>).to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"jsonmq:anotherQueue"</em></strong>)</pre><p>which would be using the queueus "foo.myQueue" and "foo.anotherQueue"
and would use the given Jackson Data Format to
marshal on and off the queue.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_when_to_use_bindings"></a>When to use Bindings</h2></div></div></div><p>If you only use an endpoint once in a single route; a binding may
actually be more complex and more work than just using the 'raw'
endpoint directly and using explicit marshalling and validation in the
camel route as normal.</p><p>However bindings can help when you are composing many routes together;
or using a single route as a 'template' that is configured input and
output endpoints; bindings then provide a nice way to wrap up a contract
and endpoint together.</p><p>Another good use case for bindings is when you are using many endpoints
which use the same binding; rather than always having to mention a
specific data format or validation rule, you can just use the
BindingComponent to wrap the endpoints in the binding of your choice.</p><p>So bindings are a composition tool really; only use them when they make
sense - the extra complexity may not be worth it unless you have lots of
routes or endpoints.</p></div></div></body></html>