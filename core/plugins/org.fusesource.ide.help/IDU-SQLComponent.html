<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SQL Component</title><link rel="stylesheet" type="text/css" href="eclipse_book.css"><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"><meta name="keywords" content="ESB, Apache ServiceMix, Open Source, open source, integration, OSGi, enterprise service bus, Apache ServiceMix documentation, Apache Karaf, Red Hat JBoss Fuse, Red Hat JBoss Fuse documentation"><meta name="keywords" content="ESB, Apache ServiceMix, Open Source, open source, integration, OSGi, enterprise service bus, Apache ServiceMix documentation, Apache Karaf, Red Hat JBoss Fuse, Red Hat JBoss Fuse documentation"><link rel="home" href="index.html" title="Red Hat JBoss Fuse Tooling for Eclipse"><link rel="up" href="IDU-Components.html" title="Apache Camel Component Reference"><link rel="prev" href="IDU-SpringWebServices.html" title="Spring Web Services"><link rel="next" href="IDU-SQLStored.html" title="SQL Stored Procedure"><link rel="copyright" href="tmdisclaim.html" title="Trademark Disclaimer"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="IDU-SQLComponent"></a>SQL Component</h1></div></div></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-SQLComponent_HSH_SQLComponent"></a>SQL Component</h2></div></div></div><p>The <span class="bold"><strong>sql:</strong></span> component allows you to work with databases
      using JDBC queries. The difference between this component and <a href="IDU-JDBC.html" class="olink">JDBC</a> component is that in case of SQL the query is a property of the endpoint and
      it uses message payload as parameters passed to the query.</p><p>This component uses <code class="literal">spring-jdbc</code> behind the scenes for the actual SQL
    handling.</p><p>The SQL component also supports:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>a JDBC based repository for the <span class="phrase">Idempotent Consumer</span> EIP pattern. See further
          below.</p></li><li class="listitem"><p>a JDBC based repository for the 
              <span class="phrase">Aggregator</span> EIP pattern. See further below.</p></li></ul></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="imagesdb/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>This component can be used as a <a class="link" href="http://camel.apache.org/transactional-client.html" target="_top">Transactional Client</a>.</p></td></tr></table></div></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e167927"></a>Camel on EAP deployment</h2></div></div></div><p>This component is supported by the Camel on EAP (Wildfly Camel) framework, which
            offers a simplified deployment model on the Red Hat JBoss Enterprise Application Platform (JBoss EAP) container.
 </p><p>When used in conjunction with the <code class="varname">camel-cdi</code> component, Java EE
            annotations make a datasource available to Camel. The following example uses the
                <code class="classname">@Named</code> annotation so that Camel can locate the desired
            datasource:</p><pre class="programlisting">public class DatasourceProducer {
    @Resource(name = "java:jboss/datasources/ExampleDS")
    DataSource dataSource;

    @Produces
    @Named("wildFlyExampleDS")
    public DataSource getDataSource() {
        return dataSource;
    }
}</pre><p> The datasource can now be referenced through the <code class="code">dataSource</code> parameter on
            the <code class="varname">camel-sql</code> endpoint configuration, as follows:</p><pre class="programlisting">@ApplicationScoped
@ContextName("camel-sql-cdi-context")
@Startup
public class CdiRouteBuilder extends RouteBuilder {
    @Override
    public void configure() throws Exception {
        from("sql:select name from information_schema.users?dataSource=wildFlyExampleDS")
        .to("direct:end");
    }
}</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-SQLComponent_HSH_URIformat"></a>URI format</h2></div></div></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="imagesdb/warning.png"></td><th align="left">Warning</th></tr><tr><td align="left" valign="top"><p>From Camel 2.11 onwards this component can create both consumer (e.g.
                    <code class="code">from()</code>) and producer endpoints (e. g. <code class="code">to()</code>). In
                previous versions, it could only act as a producer.</p></td></tr></table></div><p>The SQL component uses the following endpoint URI notation:</p><pre class="programlisting">sql:select * from table where id=# order by name[?options]</pre><p>From Camel 2.11 onwards you can use named parameters by using
                <code class="literal">#name_of_the_parameter</code> style as shown:</p><pre class="programlisting">sql:select * from table where id=:#myId order by name[?options]</pre><p>When using named parameters, Camel will lookup the names from, in the given precedence:
      1. from message body if its a <code class="literal">java.util.Map</code>
      2. from message headers</p><p>If a named parameter cannot be resolved, then an exception is thrown.</p><p>From Camel 2.14 onward you can use Simple expressions as parameters as
          shown:</p><div class="informalexample"><pre class="programlisting">sql:select * from table where id=:#${property.myId} order by name[?options]</pre></div><p>Notice that the standard <code class="literal">?</code> symbol that denotes the parameters to an SQL
      query is substituted with the <code class="literal">#</code> symbol, because the <code class="literal">?</code>
      symbol is used to specify options for the endpoint. The <code class="literal">?</code> symbol replacement can be configured on endpoint basis.</p><p>From <span class="bold"><strong>Camel 2.17</strong></span> onwards you can externalize your SQL
            queries to files in the classpath or file system as shown: </p><pre class="programlisting">sql:classpath:sql/myquery.sql[?options]</pre><p>And the <code class="code">myquery.sql</code> file is in the classpath and is just plain
            text:</p><pre class="programlisting">-- this is a comment
select *
from table
where
  id = :#${property.myId}
order by
  name</pre><p>In the file you can use multiple lines and format the SQL as you wish. And also use
            comments such as the <code class="code">&#8211;</code> dash line.</p><p>You can append query options to the URI in the following format,
        <code class="literal">?option=value&amp;option=value&amp;...</code>
    </p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-SQLComponent_HSH_Options"></a>Options</h2></div></div></div><table id="d0e168030"><tr>
        <th> Option </th>
        <th> Type </th>
        <th> Default </th>
        <th> Description </th>
      </tr><tr>
        <td><code class="literal">batch</code>
        </td>
        <td><code class="literal">boolean</code>
        </td>
        <td><code class="literal">false</code>
        </td>
        <td> <span class="bold"><strong>Camel 2.7.5, 2.8.4 and 2.9:</strong></span> Execute SQL batch update statements. See notes below on how the treatment of the inbound message body changes if this is set to <code class="literal">true</code>. </td>
      </tr><tr>
        <td><code class="literal">dataSourceRef</code>
        </td>
        <td><code class="literal">String</code>
        </td>
        <td><code class="literal">null</code>
        </td>
        <td><span class="bold"><strong>Deprecated and will be removed in Camel 3.0:</strong></span> Reference to a <code class="literal">DataSource</code> to look up in the registry. Use <code class="literal">dataSource=#theName</code> instead. </td>
      </tr><tr>
        <td><code class="literal">dataSource</code>
        </td>
        <td><code class="literal">String</code>
        </td>
        <td><code class="literal">null</code>
        </td>
        <td><span class="bold"><strong>Camel 2.11:</strong></span> Reference to a <code class="literal">DataSource</code> to look up in the registry. </td>
      </tr><tr>
        <td><code class="literal">placeholder</code></td>
        <td><code class="literal">String</code>
        </td>
        <td><code class="literal">#</code>
        </td>
        <td><span class="bold"><strong>Camel 2.4:</strong></span> Specifies a character that will be replaced to <code class="literal">?</code> in SQL query. Notice, that it is simple <code class="literal">String.replaceAll()</code> operation and no SQL parsing is involved (quoted strings will also change) </td>
      </tr><tr>
                <td><code class="literal">usePlaceholder</code></td>
                <td><code class="literal">boolean</code>
                </td>
                <td><code class="literal">true</code>
                </td>
                <td><span class="bold"><strong>Camel 2.17:</strong></span> Sets whether to use placeholder and
                    replace all placeholder characters with ? sign in the SQL queries. </td>
            </tr><tr>
        <td><code class="literal">template.&lt;xxx&gt;</code>
        </td>
        <td></td>
        <td><code class="literal">null</code>
        </td>
        <td> Sets additional options on the Spring <code class="literal">JdbcTemplate</code> that is used
          behind the scenes to execute the queries. For instance,
            <code class="literal">template.maxRows=10</code>. For detailed documentation, see the <a class="link" href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/jdbc/core/JdbcTemplate.html" target="_top">JdbcTemplate javadoc</a> documentation. </td>
      </tr><tr>
        <td><code class="literal">allowNamedParameters</code>
        </td>
        <td><code class="literal">boolean</code>
        </td>
        <td><code class="literal">true</code>
        </td>
        <td><span class="bold"><strong>Camel 2.11:</strong></span> Whether to allow using named parameters in the queries. </td>
      </tr><tr>
        <td><code class="literal">processingStrategy</code>
        </td>
        <td></td>
        <td></td>
        <td><span class="bold"><strong>Camel 2.11:</strong></span><span class="bold"><strong>SQL consumer only:</strong></span> Allows to plugin to use a custom <code class="literal">org.apache.camel.component.sql.SqlProcessingStrategy</code> to execute queries when the consumer has processed the rows/batch. </td>
      </tr><tr>
        <td><code class="literal">prepareStatementStrategy</code>
        </td>
        <td></td>
        <td></td>
        <td><span class="bold"><strong>Camel 2.11:</strong></span> Allows to plugin to use a custom <code class="literal">org.apache.camel.component.sql.SqlPrepareStatementStrategy</code> to control preparation of the query and prepared statement. </td>
      </tr><tr>
        <td><code class="literal">consumer.delay</code>
        </td>
        <td><code class="literal">long</code>
        </td>
        <td><code class="literal">500</code>
        </td>
        <td><span class="bold"><strong>Camel 2.11:</strong></span><span class="bold"><strong>SQL consumer only:</strong></span> Delay in milliseconds between each poll. </td>
      </tr><tr>
        <td><code class="literal">consumer.initialDelay</code>
        </td>
        <td><code class="literal">long</code>
        </td>
        <td><code class="literal">1000</code>
        </td>
        <td><span class="bold"><strong>Camel 2.11:</strong></span><span class="bold"><strong>SQL consumer only:</strong></span> Milliseconds before polling starts. </td>
      </tr><tr>
        <td><code class="literal">consumer.useFixedDelay</code>
        </td>
        <td><code class="literal">boolean</code>
        </td>
        <td><code class="literal">false</code>
        </td>
        <td><span class="bold"><strong>Camel 2.11:</strong></span><span class="bold"><strong>SQL consumer only:</strong></span> Set to <code class="literal">true</code> to use fixed delay between polls, otherwise fixed rate is used. See <a class="link" href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ScheduledExecutorService.html" target="_top">ScheduledExecutorService</a> in JDK for details. </td>
      </tr><tr>
        <td><code class="literal">maxMessagesPerPoll</code>
        </td>
        <td><code class="literal">int</code>
        </td>
        <td><code class="literal">0</code>
        </td>
        <td><span class="bold"><strong>Camel 2.11:</strong></span><span class="bold"><strong>SQL consumer only:</strong></span> An integer value to define the maximum number of messages to gather per poll. By default, no maximum is set. </td>
      </tr><tr>
        <td><code class="literal">useIterator</code>
                </td>
        <td><code class="literal">boolean</code>
        </td>
        <td><code class="literal">true</code>
        </td>
        <td><span class="bold"><strong>Camel 2.11:</strong></span><span class="bold"><strong>SQL consumer
                        only:</strong></span> If <code class="literal">true</code> each row returned when polling
                    will be processed individually. If <code class="literal">false</code> the entire
                        <code class="literal">java.util.List</code> of data is set as the IN body. Note that
                    in <span class="bold"><strong>Camel 2.15.x</strong></span> or older you need to prefix
                    this option with the <code class="code">consumer.</code> prefix, for example
                        <code class="code">consumer.useIterator=true</code>.</td>
      </tr><tr>
        <td><code class="literal">routeEmptyResultSet</code>
                </td>
        <td><code class="literal">boolean</code>
        </td>
        <td><code class="literal">false</code>
        </td>
        <td><span class="bold"><strong>Camel 2.11:</strong></span><span class="bold"><strong>SQL consumer
                        only:</strong></span> Whether to route a single empty <a class="link" href="Exchange" target="_top">Exchange</a> if there was no data to poll. Note that in <span class="bold"><strong>Camel 2.15.x</strong></span> or older you need to prefix this option
                    with the <code class="code">consumer.</code> prefix, for example
                        <code class="code">consumer.useIterator=true</code>.</td>
      </tr><tr>
        <td><code class="literal">onConsume</code>
                </td>
        <td><code class="literal">String</code>
        </td>
        <td><code class="literal">null</code>
        </td>
        <td><span class="bold"><strong>Camel 2.11:</strong></span><span class="bold"><strong>SQL consumer
                        only:</strong></span> After processing each row then this query can be executed,
                    if the <a class="link" href="Exchange" target="_top">Exchange</a> was processed successfully, for
                    example to mark the row as processed. The query can have parameter. Note that in
                        <span class="bold"><strong>Camel 2.15.x</strong></span> or older you need to prefix
                    this option with the <code class="code">consumer.</code> prefix, for example
                        <code class="code">consumer.useIterator=true</code>.</td>
      </tr><tr>
        <td><code class="literal">onConsumeFailed</code>
                </td>
        <td><code class="literal">String</code>
        </td>
        <td><code class="literal">null</code>
        </td>
        <td><span class="bold"><strong>Camel 2.11:</strong></span><span class="bold"><strong>SQL consumer
                        only:</strong></span> After processing each row then this query can be executed,
                    if the <a class="link" href="Exchange" target="_top">Exchange</a> failed, for example to mark the
                    row as failed. The query can have parameter. Note that in <span class="bold"><strong>Camel 2.15.x</strong></span> or older you need to prefix this option with the
                        <code class="code">consumer.</code> prefix, for example
                        <code class="code">consumer.useIterator=true</code>.</td>
      </tr><tr>
        <td><code class="literal">onConsumeBatchComplete</code>
                </td>
        <td><code class="literal">String</code>
        </td>
        <td><code class="literal">null</code>
        </td>
        <td><span class="bold"><strong>Camel 2.11:</strong></span><span class="bold"><strong>SQL consumer
                        only:</strong></span> After processing the entire batch, this query can be
                    executed to bulk update rows etc. The query cannot have parameters. Note that in
                        <span class="bold"><strong>Camel 2.15.x</strong></span> or older you need to prefix
                    this option with the <code class="code">consumer.</code> prefix, for example
                        <code class="code">consumer.useIterator=true</code>.</td>
      </tr><tr>
        <td><code class="literal">expectedUpdateCount</code>
                </td>
        <td><code class="literal">int</code>
        </td>
        <td><code class="literal">\-1</code>
        </td>
        <td><span class="bold"><strong>Camel 2.11:</strong></span><span class="bold"><strong>SQL consumer
                        only:</strong></span> If using <code class="literal">consumer.onConsume</code> then this
                    option can be used to set an expected number of rows being updated. Typically
                    you may set this to <code class="literal">1</code> to expect one row to be updated. Note
                    that in <span class="bold"><strong>Camel 2.15.x</strong></span> or older you need to
                    prefix this option with the <code class="code">consumer.</code> prefix, for example
                        <code class="code">consumer.useIterator=true</code>.</td>
      </tr><tr>
        <td><code class="literal">breakBatchOnConsumeFail</code>
                </td>
        <td><code class="literal">boolean</code>
        </td>
        <td><code class="literal">false</code>
        </td>
        <td><span class="bold"><strong>Camel 2.11:</strong></span><span class="bold"><strong>SQL consumer
                        only:</strong></span> If using <code class="literal">consumer.onConsume</code> and it
                    fails, then this option controls whether to break out of the batch or continue
                    processing the next row from the batch. Note that in <span class="bold"><strong>Camel
                        2.15.x</strong></span> or older you need to prefix this option with the
                        <code class="code">consumer.</code> prefix, for example
                        <code class="code">consumer.useIterator=true</code>.</td>
      </tr><tr>
        <td><code class="literal">alwaysPopulateStatement</code>
        </td>
        <td><code class="literal">boolean</code>
        </td>
        <td><code class="literal">false</code>
        </td>
        <td><span class="bold"><strong>Camel 2.11:</strong></span><span class="bold"><strong>SQL producer only:</strong></span> If enabled then the <code class="literal">populateStatement</code> method from <code class="literal">org.apache.camel.component.sql.SqlPrepareStatementStrategy</code> is always invoked, also if there is no expected parameters to be prepared. When this is <code class="literal">false</code> then the <code class="literal">populateStatement</code> is only invoked if there is 1 or more expected parameters to be set; for example this avoids reading the message body/headers for SQL queries with no parameters. </td>
      </tr><tr>
        <td><code class="literal">separator</code>
        </td>
        <td><code class="literal">char</code>
        </td>
        <td><code class="literal">,</code>
        </td>
        <td><span class="bold"><strong>Camel 2.11.1:</strong></span> The separator to use when parameter values is taken from message body (if the body is a String type), to be inserted at # placeholders. Notice if you use named parameters, then a <code class="literal">Map</code> type is used instead. </td>
      </tr><tr>
        <td><code class="literal">outputType</code>
        </td>
        <td><code class="literal">String</code>
        </td>
        <td><code class="literal">SelectList</code>
        </td>
        <td>
          <p><span class="bold"><strong>Camel 2.12.0:</strong></span> Make the output of consumer or producer to <code class="literal">SelectList</code> as List of Map, or <code class="literal">SelectOne</code> as single Java object in the following way:
            a) If the query has only single column, then that JDBC Column object is returned. (such as <code class="literal">SELECT COUNT( * ) FROM PROJECT</code> will return a Long object.
            b) If the query has more than one column, then it will return a Map of that result.
            c) If the <code class="literal">outputClass</code> is set, then it will convert the query result into an Java bean object by calling all the setters that match the column names. It will assume your class has a default constructor to create instance with.
            d) If the query resulted in more than one rows, it throws an non-unique result exception.</p>
                    <p>From <span class="bold"><strong>Camel 2.14.1</strong></span> onwards, the
                            <code class="code">SelectList</code> also supports mapping each row to a Java object
                        as the <code class="code">SelectOne</code> does (only step c).</p>
        </td>
      </tr><tr>
        <td><code class="literal">outputClass</code>
        </td>
        <td><code class="literal">String</code>
        </td>
        <td><code class="literal">null</code>
        </td>
        <td><span class="bold"><strong>Camel 2.12.0:</strong></span> Specify the full package and class name to use as conversion when <code class="literal">outputType=SelectOne</code>. </td>
      </tr><tr>
                <td><code class="literal">outputHeader</code>
                </td>
                <td><code class="literal">String</code>
                </td>
                <td><code class="literal">null</code>
                </td>
                <td><span class="bold"><strong>Camel 2.15:</strong></span> To store the result as a header
                    instead of the message body. This allows to preserve the existing message body
                    as-is. </td>
            </tr><tr>
        <td><code class="literal">parametersCount</code>
        </td>
        <td><code class="literal">int</code>
        </td>
        <td><code class="literal">0</code>
        </td>
        <td><span class="bold"><strong>Camel 2.11.2/2.12.0</strong></span> If set greater than zero, then Camel will use this count value of parameters to replace instead of querying via JDBC metadata API. This is useful if the JDBC vendor could not return correct parameters count, then user may override instead. </td>
      </tr><tr>
        <td><code class="literal">noop</code></td>
        <td><code class="literal">boolean</code>
        </td>
        <td>
                    <code class="code">false</code>
                </td>
        <td><span class="bold"><strong>Camel 2.12.0</strong></span> If set, will ignore the results of the SQL query and use the existing IN message as the OUT message for the continuation of processing </td>
      </tr><tr>
                <td><code class="literal">useMessageBodyForSql</code></td>
                <td><code class="literal">boolean</code>
                </td>
                <td>
                    <code class="code">false</code>
                </td>
                <td><span class="bold"><strong>Camel 2.16:</strong></span> Whether to use the message body as
                    the SQL and then headers for parameters. If this option is enabled then the SQL
                    in the uri is not used. The SQL parameters must then be provided in a header
                    with the key CamelSqlParameters. This option is only for the producer.</td>
            </tr><tr>
                <td><code class="literal">transacted</code></td>
                <td><code class="literal">boolean</code>
                </td>
                <td>
                    <code class="code">false</code>
                </td>
                <td><span class="bold"><strong>Camel 2.16.2:</strong></span> SQL consumer only:Enables or
                    disables transaction. If enabled then if processing an exchange failed then the
                    consumer break out processing any further exchanges to cause a rollback
                    eager.</td>
            </tr></table></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-SQLComponent_HSH_Treatmentofthemessagebody"></a>Treatment of the message body</h2></div></div></div><p>The SQL component tries to convert the message body to an object of
        <code class="literal">java.util.Iterator</code> type and then uses this iterator to fill the query
      parameters (where each query parameter is represented by a <code class="literal">#</code> symbol, or other configured placeholder, in the
      endpoint URI). If the message body is not an array or collection, the conversion results in an
      iterator that iterates over only one object, which is the body itself.</p><p>For example, if the message body is an instance of <code class="literal">java.util.List</code>, the
      first item in the list is substituted into the first occurrence of <code class="literal">#</code> in the
      SQL query, the second item in the list is substituted into the second occurrence of
        <code class="literal">#</code>, and so on.</p><p>If <code class="literal">batch</code> is set to <code class="literal">true</code>, then the interpretation of the inbound message body changes slightly - instead of an iterator of parameters, the component expects an iterator that contains the parameter iterators; the size of the outer iterator determines the batch size.</p><p>From <span class="bold"><strong>Camel 2.16</strong></span> onwards you can use the option
                <code class="code">useMessageBodyForSql</code> that allows to use the message body as the SQL
            statement, and then the SQL parameters must be provided in a header with the key
                <code class="code">SqlConstants.SQL_PARAMETERS</code>. This allows the SQL component to work more
            dynamic as the SQL query is from the message body.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-SQLComponent_HSH_Resultofthequery"></a>Result of the query</h2></div></div></div><p>For <code class="literal">select</code> operations, the result is an instance of
        <code class="literal">List&lt;Map&lt;String, Object&gt;&gt;</code> type, as returned by the <a class="link" href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/jdbc/core/JdbcTemplate.html#queryForList(java.lang.String,%20java.lang.Object%91%93)" target="_top">JdbcTemplate.queryForList()</a> method. For <code class="literal">update</code> operations, the
      result is the number of updated rows, returned as an <code class="literal">Integer</code>.</p><p>By default, the result is placed in the message body. If the <code class="code">outputHeader</code>
            parameter is set, the result is placed in the header. This is an alternative to using a
            full message enrichment pattern to add headers, it provides a concise syntax for
            querying a sequence or some other small value into a header. It is convenient to use
                <code class="code">outputHeader</code> and <code class="code">outputType</code> together, for example:</p><pre class="programlisting">from("jms:order.inbox")
	.to("sql:select order_seq.nextval from dual?outputHeader=OrderId&amp;outputType=SelectOne")
	.to("jms:order.booking");</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SQLComponent-UsingStreamList"></a>Using StreamList</h2></div></div></div><p>From <span class="bold"><strong>Camel 2.18</strong></span> onwards the producer supports
                <code class="code">outputType=StreamList</code> that uses an iterator to stream the output of the
            query. This allows to process the data in a streaming fashion which for example can be
            used by the&nbsp;Splitter EIP to process each row one at a time, and load data from the
            database as needed.</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"direct:withSplitModel"</em></strong>)
        .to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"sql:select * from projects order by id?outputType=StreamList&amp;outputClass=org.apache.camel.component.sql.ProjectModel"</em></strong>)
        .to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"log:stream"</em></strong>)
        .split(body()).streaming()
            .to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"log:row"</em></strong>)
            .to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"mock:result"</em></strong>)
        .end();</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-SQLComponent_HSH_Headervalues"></a>Header values</h2></div></div></div><p>When performing <code class="literal">update</code> operations, the SQL Component stores the update
      count in the following message headers:</p><table id="d0e168963"><tr>
        <th> Header </th>
        <th> Description </th>
      </tr><tr>
        <td><code class="literal">CamelSqlUpdateCount</code>
        </td>
        <td> Apache Camel 2.0: The number of rows updated for <code class="literal">update</code> operations,
                    returned as an <code class="literal">Integer</code> object. This header&nbsp;is not provided
                    when using <code class="code">outputType=StreamList</code>.</td>
      </tr><tr>
        <td><code class="literal">CamelSqlRowCount</code>
        </td>
        <td> Apache Camel 2.0: The number of rows returned for <code class="literal">select</code> operations,
                    returned as an <code class="literal">Integer</code> object. This header&nbsp;is not provided
                    when using <code class="code">outputType=StreamList</code>.</td>
      </tr><tr>
        <td><code class="literal">CamelSqlQuery</code>
        </td>
        <td><span class="bold"><strong>Camel 2.8:</strong></span> Query to execute. This query takes
          precedence over the query specified in the endpoint URI. Note that query parameters in the
          header <span class="emphasis"><em>are</em></span> represented by a <code class="literal">?</code> instead of a
            <code class="literal">#</code> symbol </td>
      </tr></table><p>When performing <code class="code">insert</code> operations, the SQL Component stores the rows
          with the generated keys and number of these rown in the following message headers
          (<span class="strong"><strong>Available as of Camel 2.12.4,
              2.13.1</strong></span>):</p><table id="d0e169039"><colgroup> </colgroup><thead><tr>
                  <td>
                      <p>Header</p>
                  </td>
                  <td>
                      <p>Description</p>
                  </td>
              </tr></thead><tbody><tr>
                  <td>
                        <code class="code">CamelSqlGeneratedKeysRowCount</code>
                    </td>
                  <td>
                      <p>The number of rows in the header that contains generated
                          keys.</p>
                  </td>
              </tr><tr>
                  <td>
                        <code class="code">CamelSqlGeneratedKeyRows</code>
                    </td>
                  <td>
                      <p>Rows that contains the generated keys (a list of maps of
                          keys).</p>
                  </td>
              </tr></tbody></table></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="scroll-bookmark-1863"></a>Generated keys</h2></div></div></div><p><span class="strong"><strong>Available as of Camel 2.12.4, 2.13.1 and 2.14
          </strong></span></p><p>If you insert data using SQL INSERT, then the RDBMS may support auto generated
              keys. You can instruct the SQL producer to return the generated keys in headers. To
              do that set the header <code class="code">CamelSqlRetrieveGeneratedKeys=true</code>. Then the
              generated keys will be provided as headers with the keys listed in the table
              above.</p><p>You can see more details in this <a class="link" href="https://git-wip-us.apache.org/repos/asf?p=camel.git;a=blob_plain;f=components/camel-sql/src/test/java/org/apache/camel/component/sql/SqlGeneratedKeysTest.java;hb=3962b23f94bb4bc23011b931add08c3f6833c82e" target="_top">unit test</a>.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-SQLComponent_HSH_ConfigurationinCamel151orhigher"></a>Configuration</h2></div></div></div><p>You can now set a reference to a <code class="literal">DataSource</code> in the URI directly:</p><pre class="programlisting">sql:select * from table where id=# order by name?dataSourceRef=myDS</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-SQLComponent_HSH_Sample"></a>Sample</h2></div></div></div><p>In the sample below we execute a query and retrieve the result as a
        <code class="literal">List</code> of rows, where each row is a <code class="literal">Map&lt;String,
        Object</code> and the key is the column name. </p><p>First, we set up a table to use for our sample. As this is based on an unit test, we do it
      java code:</p><pre class="programlisting">// this is the database we create with some initial data for our unit test
db = new EmbeddedDatabaseBuilder()
    .setType(EmbeddedDatabaseType.DERBY).addScript("sql/createAndPopulateDatabase.sql").build();
</pre><p>The SQL script <code class="literal">createAndPopulateDatabase.sql</code> we execute looks like as described below:</p><pre class="programlisting">create table projects (id integer primary key, project varchar(10), license varchar(5));
insert into projects values (1, 'Camel', 'ASF');
insert into projects values (2, 'AMQ', 'ASF');
insert into projects values (3, 'Linux', 'XXX');</pre><p>Then we configure our route and our <code class="literal">sql</code> component. Notice that we use a
        <code class="literal">direct</code> endpoint in front of the <code class="literal">sql</code> endpoint. This
      allows us to send an exchange to the <code class="literal">direct</code> endpoint with the URI,
        <code class="literal">direct:simple</code>, which is much easier for the client to use than the long
        <code class="literal">sql:</code> URI. Note that the <code class="literal">DataSource</code> is looked up up in
      the registry, so we can use standard Spring XML to configure our
      <code class="literal">DataSource</code>.</p><pre class="programlisting">from("direct:simple")
    .to("sql:select * from projects where license = # order by id?dataSourceRef=jdbc/myDataSource")
    .to("mock:result");</pre><p>And then we fire the message into the <code class="literal">direct</code> endpoint that will route
      it to our <code class="literal">sql</code> component that queries the database.</p><pre class="programlisting">MockEndpoint mock = getMockEndpoint("mock:result");
mock.expectedMessageCount(1);

// send the query to direct that will route it to the sql where we will execute the query
// and bind the parameters with the data from the body. The body only contains one value
// in this case (XXX) but if we should use multi values then the body will be iterated
// so we could supply a List&lt;String&gt; instead containing each binding value.
template.sendBody("direct:simple", "XXX");

mock.assertIsSatisfied();

// the result is a List
List&lt;?&gt; received = assertIsInstanceOf(List.class, mock.getReceivedExchanges().get(0).getIn().getBody());

// and each row in the list is a Map
Map&lt;?, ?&gt; row = assertIsInstanceOf(Map.class, received.get(0));

// and we should be able the get the project from the map that should be Linux
assertEquals("Linux", row.get("PROJECT"));</pre><p>We could configure the <code class="literal">DataSource</code> in Spring XML as follows:</p><pre class="programlisting"> &lt;jee:jndi-lookup id="myDS" jndi-name="jdbc/myDataSource"/&gt; </pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-SQLComponent_HSH_Usingnamedparameters"></a>Using named parameters</h2></div></div></div><p></p><p><span class="bold"><strong>Available as of Camel 2.11</strong></span>
    </p><p>In the given route below, we want to get all the projects from the projects table. Notice the SQL query has 2 named parameters, :#lic and :#min.
      Camel will then lookup for these parameters from the message body or message headers. Notice in the example above we set two headers with constant value
      for the named parameters:</p><pre class="programlisting">
   from("direct:projects")
     .setHeader("lic", constant("ASF"))
     .setHeader("min", constant(123))
     .to("sql:select * from projects where license = :#lic and id &gt; :#min order by id")
</pre><p>Though if the message body is a <code class="literal">java.util.Map</code> then the named parameters will be taken from the body.</p><pre class="programlisting">   from("direct:projects")
     .to("sql:select * from projects where license = :#lic and id &gt; :#min order by id")</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="scroll-bookmark-1867"></a>Using expression parameters</h2></div></div></div><p><span class="strong"><strong>Available as of Camel 2.14</strong></span></p><p>In the given route below, we want to get all the project from the database. It
            uses the body of the exchange for defining the license and uses the value of a
            property as the second parameter.</p><div class="informalexample"><pre class="programlisting">from("direct:projects")
  .setBody(constant("ASF"))
  .setProperty("min", constant(123))
  .to("sql:select * from projects where license = :#${body} and id &gt; :#${property.min} order by id")</pre></div></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e169212"></a>Using IN queries with dynamic values</h2></div></div></div><p>From <span class="bold"><strong>Camel 2.17</strong></span> onwards the SQL producer allows to
            use SQL queries with IN statements, where the IN values are dynamically computed. For
            example, from the message body or header, and so on.</p><p>To use IN, you need to:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Prefix the parameter name with <code class="code">in:</code> and</p></li><li class="listitem"><p>Add <code class="code">( )</code> around the parameter</p></li></ul></div><p>For example, assume the following query is used:</p><pre class="programlisting">-- this is a comment
select *
from projects
where project in (:#in:names)
order by id</pre><p>In the following route:</p><pre class="programlisting">from("direct:query")
    .to("sql:classpath:sql/selectProjectsIn.sql")
    .to("log:query")
    .to("mock:query");</pre><p>Then the IN query can use a header with the key names having dynamic values such
            as:</p><pre class="programlisting">// use an array
template.requestBodyAndHeader("direct:query", "Hi there!", "names", new String[]{"Camel", "AMQ"});


// use a list
List&lt;String&gt; names = new ArrayList&lt;String&gt;();
names.add("Camel");
names.add("AMQ");

template.requestBodyAndHeader("direct:query", "Hi there!", "names", names);


// use a string separated values with comma
template.requestBodyAndHeader("direct:query", "Hi there!", "names", "Camel,AMQ");</pre><p>The query can also be specified in the endpoint instead of being externalized (note
            that externalizing makes maintaining the SQL queries easier):</p><pre class="programlisting">from("direct:query")
    .to("sql:select * from projects where project in (:#in:names) order by id")
    .to("log:query")
    .to("mock:query");</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-SQLComponent_HSH_UsingtheJDBCbasedidempotentrepository"></a>Using the JDBC based idempotent repository</h2></div></div></div><p>In this section we will use the JDBC based idempotent repository.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: Abstract class"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="imagesdb/tip.png"></td><th align="left">Abstract class</th></tr><tr><td align="left" valign="top"><p>From Camel 2.9 onwards there is an abstract class <code class="literal">org.apache.camel.processor.idempotent.jdbc.AbstractJdbcMessageIdRepository</code> you can extend to build custom JDBC idempotent repository.</p></td></tr></table></div><p>First we have to create the database table which will be used by the idempotent
      repository.</p><p>In <span class="bold"><strong>Camel 2.8</strong></span>, we added the
        <code class="code">createdAt</code> column:</p><pre class="programlisting"> CREATE TABLE CAMEL_MESSAGEPROCESSED (
   processorName VARCHAR(255),
   messageId VARCHAR(100),
   createdAt TIMESTAMP
 )</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="imagesdb/warning.png"></td><th align="left">Warning</th></tr><tr><td align="left" valign="top"><p>The SQL Server <span class="strong"><strong>TIMESTAMP</strong></span> type is a
              fixed-length binary-string type. It does not map to any of the JDBC time types:
              <span class="strong"><strong>DATE</strong></span>, <span class="strong"><strong>TIME</strong></span>, or <span class="strong"><strong>TIMESTAMP</strong></span>.</p></td></tr></table></div><p>We recommend to have a unique constraint on the columns processorName and messageId. Because the syntax for this constraint differs for database to database, we do not show it here.</p><p>Second we need to setup a <code class="literal">javax.sql.DataSource</code> in the spring XML file:</p><pre class="programlisting">&lt;jdbc:embedded-database id="dataSource" type="DERBY" /&gt;</pre><p>And finally we can create our JDBC idempotent repository in the spring XML file as well:</p><pre class="programlisting">&lt;bean id="messageIdRepository" class="org.apache.camel.processor.idempotent.jdbc.JdbcMessageIdRepository"&gt;
	&lt;constructor-arg ref="dataSource" /&gt;
	&lt;constructor-arg value="myProcessorName" /&gt;
&lt;/bean&gt;

&lt;camel:camelContext&gt;
	&lt;camel:errorHandler id="deadLetterChannel" type="DeadLetterChannel" deadLetterUri="mock:error"&gt;
		&lt;camel:redeliveryPolicy maximumRedeliveries="0" maximumRedeliveryDelay="0" logStackTrace="false" /&gt;
	&lt;/camel:errorHandler&gt;
	
	&lt;camel:route id="JdbcMessageIdRepositoryTest" errorHandlerRef="deadLetterChannel"&gt;
		&lt;camel:from uri="direct:start" /&gt;
		&lt;camel:idempotentConsumer messageIdRepositoryRef="messageIdRepository"&gt;
			&lt;camel:header&gt;messageId&lt;/camel:header&gt;
			&lt;camel:to uri="mock:result" /&gt;
		&lt;/camel:idempotentConsumer&gt;
	&lt;/camel:route&gt;
&lt;/camel:camelContext&gt;</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-SQLComponent_HSH_CustomizetheJdbcMessageIdRepository"></a>Customize the JdbcMessageIdRepository</h2></div></div></div><p>Starting with <span class="bold"><strong>Camel 2.9.1</strong></span> you have a few options to
            tune the
                <code class="literal">org.apache.camel.processor.idempotent.jdbc.JdbcMessageIdRepository</code>
            for your needs:</p><table id="d0e169316"><tr>
                <th> Parameter </th>
                <th> Default Value </th>
                <th> Description </th>
            </tr><tr>
                <td>
                    <code class="code">createTableIfNotExists</code>
                </td>
                <td>
                    <code class="code">true</code>
                </td>
                <td> Defines whether or not Camel should try to create the table if it doesn't
                    exist. </td>
            </tr><tr>
                <td>
                    <code class="code">tableExistsString</code>
                </td>
                <td> SELECT 1 FROM CAMEL_MESSAGEPROCESSED WHERE 1 = 0 </td>
                <td> This query is used to figure out whether the table already exists or not. It
                    must throw an exception to indicate the table doesn't exist. </td>
            </tr><tr>
                <td>
                    <code class="code">createString</code>
                </td>
                <td> CREATE TABLE CAMEL_MESSAGEPROCESSED (processorName VARCHAR(255), messageId
                    VARCHAR(100), createdAt TIMESTAMP) </td>
                <td> The statement which is used to create the table. </td>
            </tr><tr>
                <td>
                    <code class="code">queryString</code>
                </td>
                <td> SELECT COUNT(*) FROM CAMEL_MESSAGEPROCESSED WHERE processorName = ? AND
                    messageId = ? </td>
                <td> The query which is used to figure out whether the message already exists in the
                    repository (the result is not equals to '0'). It takes two parameters. This
                    first one is the processor name (<code class="literal">String</code>) and the second one
                    is the message id (<code class="literal">String</code>). </td>
            </tr><tr>
                <td>
                    <code class="code">insertString</code>
                </td>
                <td> INSERT INTO CAMEL_MESSAGEPROCESSED (processorName, messageId, createdAt) VALUES
                    (?, ?, ?) </td>
                <td> The statement which is used to add the entry into the table. It takes three
                    parameter. The first one is the processor name (<code class="literal">String</code>), the
                    second one is the message id (<code class="literal">String</code>) and the third one is
                    the timestamp (<code class="literal">java.sql.Timestamp</code>) when this entry was added
                    to the repository. </td>
            </tr><tr>
                <td>
                    <code class="code">deleteString</code>
                </td>
                <td> DELETE FROM CAMEL_MESSAGEPROCESSED WHERE processorName = ? AND messageId = ? </td>
                <td> The statement which is used to delete the entry from the database. It takes two
                    parameter. This first one is the processor name (<code class="literal">String</code>) and
                    the second one is the message id (<code class="literal">String</code>). </td>
            </tr></table><p>A customized
                <code class="literal">org.apache.camel.processor.idempotent.jdbc.JdbcMessageIdRepository</code>
            could look like:</p><pre class="programlisting">&lt;bean id="messageIdRepository" class="org.apache.camel.processor.idempotent.jdbc.JdbcMessageIdRepository"&gt;
	&lt;constructor-arg ref="dataSource" /&gt;
	&lt;constructor-arg value="myProcessorName" /&gt;
	&lt;property name="tableExistsString" value="SELECT 1 FROM CUSTOMIZED_MESSAGE_REPOSITORY WHERE 1 = 0" /&gt;
	&lt;property name="createString" value="CREATE TABLE CUSTOMIZED_MESSAGE_REPOSITORY (processorName VARCHAR(255), messageId VARCHAR(100), createdAt TIMESTAMP)" /&gt;
	&lt;property name="queryString" value="SELECT COUNT(*) FROM CUSTOMIZED_MESSAGE_REPOSITORY WHERE processorName = ? AND messageId = ?" /&gt;
	&lt;property name="insertString" value="INSERT INTO CUSTOMIZED_MESSAGE_REPOSITORY (processorName, messageId, createdAt) VALUES (?, ?, ?)" /&gt;
	&lt;property name="deleteString" value="DELETE FROM CUSTOMIZED_MESSAGE_REPOSITORY WHERE processorName = ? AND messageId = ?" /&gt;
&lt;/bean&gt;
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-SQLComponent_HSH_UsingtheJDBCbasedaggregationrepository"></a>Using the JDBC based aggregation repository</h2></div></div></div><p><span class="bold"><strong>Available as of Camel 2.6</strong></span>
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important: Using JdbcAggregationRepository in Camel 2.6"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="imagesdb/important.png"></td><th align="left">Using JdbcAggregationRepository in Camel 2.6</th></tr><tr><td align="left" valign="top"><p>In Camel 2.6, the JdbcAggregationRepository is provided in the <code class="literal">camel-jdbc-aggregator</code> component. From Camel 2.7 onwards, the <code class="literal">JdbcAggregationRepository</code> is provided in the <code class="literal">camel-sql</code> component.</p></td></tr></table></div><p><code class="literal">JdbcAggregationRepository</code> is an
        <code class="literal">AggregationRepository</code> which on the fly persists the aggregated messages.
      This ensures that you will not loose messages, as the default aggregator will use an in memory
      only <code class="literal">AggregationRepository</code>. The
        <code class="literal">JdbcAggregationRepository</code> allows together with Camel to provide
        persistent support for the 
        <span class="phrase">Aggregator</span>.</p><p>It has the following options:</p><table id="d0e169483"><tr>
        <th> Option </th>
        <th> Type </th>
        <th> Description </th>
      </tr><tr>
        <td><code class="literal">dataSource</code>
        </td>
        <td><code class="literal">DataSource</code>
        </td>
        <td><span class="bold"><strong>Mandatory:</strong></span> The <code class="literal">javax.sql.DataSource</code> to use for accessing the database. </td>
      </tr><tr>
        <td><code class="literal">repositoryName</code>
        </td>
        <td><code class="literal">String</code>
        </td>
        <td><span class="bold"><strong>Mandatory:</strong></span> The name of the repository. </td>
      </tr><tr>
        <td><code class="literal">transactionManager</code>
        </td>
        <td><code class="literal">TransactionManager</code>
        </td>
        <td><span class="bold"><strong>Mandatory:</strong></span> The <code class="literal">org.springframework.transaction.PlatformTransactionManager</code> to mange transactions for the database. The TransactionManager must be able to support databases. </td>
      </tr><tr>
        <td><code class="literal">lobHandler</code>
        </td>
        <td><code class="literal">LobHandler</code>
        </td>
        <td> A <code class="literal">org.springframework.jdbc.support.lob.LobHandler</code> to handle Lob types in the database. Use this option to use a vendor specific LobHandler, for example when using Oracle. </td>
      </tr><tr>
        <td><code class="literal">returnOldExchange</code>
        </td>
        <td> boolean </td>
        <td> Whether the get operation should return the old existing Exchange if any existed. By default this option is <code class="literal">false</code> to optimize as we do not need the old exchange when aggregating. </td>
      </tr><tr>
        <td><code class="literal">useRecovery</code>
        </td>
        <td> boolean </td>
        <td> Whether or not recovery is enabled. This option is by default <code class="literal">true</code>.
            When enabled the Camel 
            <span class="phrase">Aggregator</span> automatic recover failed aggregated exchange and have them
          resubmitted. </td>
      </tr><tr>
        <td><code class="literal">recoveryInterval</code>
        </td>
        <td> long </td>
        <td> If recovery is enabled then a background task is run every x'th time to scan for failed exchanges to recover and resubmit. By default this interval is 5000 millis. </td>
      </tr><tr>
        <td><code class="literal">maximumRedeliveries</code>
        </td>
        <td> int </td>
        <td> Allows you to limit the maximum number of redelivery attempts for a recovered exchange. If enabled then the Exchange will be moved to the dead letter channel if all redelivery attempts failed. By default this option is disabled. If this option is used then the <code class="literal">deadLetterUri</code> option must also be provided. </td>
      </tr><tr>
        <td><code class="literal">deadLetterUri</code>
        </td>
        <td> String </td>
        <td> An endpoint uri for a <span class="phrase">Dead
            Letter</span> Channel where exhausted recovered Exchanges will be moved. If this option
          is used, the <code class="literal">maximumRedeliveries</code> option must also be provided. </td>
      </tr><tr>
        <td><code class="literal">storeBodyAsText</code>
        </td>
        <td> boolean </td>
        <td><span class="bold"><strong>Camel 2.11:</strong></span> Whether to store the message body as String which is human readable. By default this option is <code class="literal">false</code> storing the body in binary format. </td>
      </tr><tr>
        <td><code class="literal">headersToStoreAsText</code>
        </td>
        <td><code class="literal">List&lt;String&gt;</code>
        </td>
        <td><span class="bold"><strong>Camel 2.11:</strong></span> Allows to store headers as String which is human readable. By default this option is disabled, storing the headers in binary format. </td>
      </tr><tr>
        <td><code class="literal">optimisticLocking</code>
        </td>
        <td><code class="literal">false</code>
        </td>
        <td><span class="bold"><strong>Camel 2.12:</strong></span> To turn on optimistic locking, which often would be needed in clustered environments where multiple Camel applications shared the same JDBC based aggregation repository. </td>
      </tr><tr>
        <td><code class="literal">jdbcOptimisticLockingExceptionMapper</code>
        </td>
        <td></td>
        <td><span class="bold"><strong>Camel 2.12:</strong></span> Allows to plugin a custom <code class="literal">org.apache.camel.processor.aggregate.jdbc.JdbcOptimisticLockingExceptionMapper</code> to map vendor specific error codes to an optimistick locking error, for Camel to perform a retry. This requires <code class="literal">optimisticLocking</code> to be enabled. </td>
      </tr></table></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-SQLComponent_HSH_Whatispreservedwhenpersisting"></a>What is preserved when persisting</h2></div></div></div><p><code class="literal">JdbcAggregationRepository</code> will only preserve any <code class="literal">Serializable</code> compatible data types. If a data type is not such a type its dropped and a <code class="literal">WARN</code> is logged. And it only persists the <code class="literal">Message</code> body and the <code class="literal">Message</code> headers. The <code class="literal">Exchange</code> properties are <span class="bold"><strong>not</strong></span> persisted. </p><p>From Camel 2.11 onwards you can store the message body and select(ed) headers as String in separate columns.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-SQLComponent_HSH_Recovery"></a>Recovery</h2></div></div></div><p>The <code class="literal">JdbcAggregationRepository</code> will by default recover any failed <a class="link" href="http://camel.apache.org/maven/camel-2.15.0/camel-core/apidocs/org/apache/camel/Exchange.html" target="_top">Exchange</a>. It does this by having a background tasks that scans for failed <a class="link" href="http://camel.apache.org/maven/camel-2.15.0/camel-core/apidocs/org/apache/camel/Exchange.html" target="_top">Exchange</a>s in the persistent store. You can use the <code class="literal">checkInterval</code> option to set how often this task runs. The recovery works as transactional which ensures that Camel will try to recover and redeliver the failed <a class="link" href="http://camel.apache.org/maven/camel-2.15.0/camel-core/apidocs/org/apache/camel/Exchange.html" target="_top">Exchange</a>. Any <a class="link" href="http://camel.apache.org/maven/camel-2.15.0/camel-core/apidocs/org/apache/camel/Exchange.html" target="_top">Exchange</a> which was found to be recovered will be restored from the persistent store and resubmitted and send out again. </p><p>The following headers is set when an <a class="link" href="http://camel.apache.org/maven/camel-2.15.0/camel-core/apidocs/org/apache/camel/Exchange.html" target="_top">Exchange</a> is being recovered/redelivered:</p><table id="d0e169782"><tr>
        <th> Header </th>
        <th> Type </th>
        <th> Description </th>
      </tr><tr>
        <td><code class="literal">Exchange.REDELIVERED</code>
        </td>
        <td> Boolean </td>
        <td> Is set to true to indicate the <a class="link" href="Exchange" target="_top">Exchange</a> is being redelivered. </td>
      </tr><tr>
        <td><code class="literal">Exchange.REDELIVERY_COUNTER</code>
        </td>
        <td> Integer </td>
        <td> The redelivery attempt, starting from 1. </td>
      </tr></table><p>Only when an <a class="link" href="Exchange" target="_top">Exchange</a> has been successfully processed it will be marked as complete which happens when the <code class="literal">confirm</code> method is invoked on the <code class="literal">AggregationRepository</code>. This means if the same <a class="link" href="Exchange" target="_top">Exchange</a> fails again it will be kept retried until it success.</p><p>You can use option <code class="literal">maximumRedeliveries</code> to limit the maximum number of redelivery attempts for a given recovered <a class="link" href="Exchange" target="_top">Exchange</a>. You must also set the <code class="literal">deadLetterUri</code> option so Camel knows where to send the <a class="link" href="Exchange" target="_top">Exchange</a> when the <code class="literal">maximumRedeliveries</code> was hit. </p><p>You can see some examples in the unit tests of camel-sql, for example <a class="link" href="https://svn.apache.org/repos/asf/camel/trunk/components/camel-sql/src/test/java/org/apache/camel/processor/aggregate/jdbc/JdbcAggregateRecoverDeadLetterChannelTest.java" target="_top">this test</a>.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-SQLComponent_HSH_Database"></a>Database</h2></div></div></div><p>To be operational, each aggregator uses two table: the aggregation and completed one. By convention the completed has the same name as the aggregation one suffixed with <code class="literal">"_COMPLETED"</code>. The name must be configured in the Spring bean with the <code class="literal">RepositoryName</code> property. In the following example aggregation will be used.</p><p>The table structure definition of both table are identical: in both case a String value is used as key (<span class="bold"><strong>id</strong></span>) whereas a Blob contains the exchange serialized in byte array.
      However one difference should be remembered: the <span class="bold"><strong>id</strong></span> field does not have the same content depending on the table.
      In the aggregation table <span class="bold"><strong>id</strong></span> holds the correlation Id used by the component to aggregate the messages. In the completed table, <span class="bold"><strong>id</strong></span> holds the id of the exchange stored in corresponding the blob field.</p><p>Here is the SQL query used to create the tables, just replace <code class="literal">"aggregation"</code> with your aggregator repository name.</p><pre class="programlisting">CREATE TABLE aggregation (
    id varchar(255) NOT NULL,
    exchange blob NOT NULL,
    constraint aggregation_pk PRIMARY KEY (id)
);
CREATE TABLE aggregation_completed (
    id varchar(255) NOT NULL,
    exchange blob NOT NULL,
    constraint aggregation_completed_pk PRIMARY KEY (id)
);</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-SQLComponent_HSH_Storingbodyandheadersastext"></a>Storing body and headers as text</h2></div></div></div><p><span class="bold"><strong>Available as of Camel 2.11</strong></span>
        </p><p>You can configure the <code class="literal">JdbcAggregationRepository</code> to store message
            body and select(ed) headers as String in separate columns. For example to store the
            body, and the following two headers <code class="literal">companyName</code> and
                <code class="literal">accountName</code> use the following SQL:</p><pre class="programlisting">
CREATE TABLE aggregationRepo3 (
    id varchar(255) NOT NULL,
    exchange blob NOT NULL,
    body varchar(1000),
    companyName varchar(1000),
    accountName varchar(1000),
    constraint aggregationRepo3_pk PRIMARY KEY (id)
);
CREATE TABLE aggregationRepo3_completed (
    id varchar(255) NOT NULL,
    exchange blob NOT NULL,
    body varchar(1000),
    companyName varchar(1000),
    accountName varchar(1000),
    constraint aggregationRepo3_completed_pk PRIMARY KEY (id)
);
</pre><p>And then configure the repository to enable this behavior as shown below:</p><pre class="programlisting">
    &lt;bean id="repo3" class="org.apache.camel.processor.aggregate.jdbc.JdbcAggregationRepository"&gt;
        &lt;property name="repositoryName" value="aggregationRepo3"/&gt;
        &lt;property name="transactionManager" ref="txManager3"/&gt;
        &lt;property name="dataSource" ref="dataSource3"/&gt;
        &lt;!-- configure to store the message body and following headers as text in the repo --&gt;
        &lt;property name="storeBodyAsText" value="true"/&gt;
        &lt;property name="headersToStoreAsText"&gt;
          &lt;list&gt;
      	    &lt;value&gt;companyName&lt;/value&gt;
    	    &lt;value&gt;accountName&lt;/value&gt;
          &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-SQLComponent_HSH_CodecSerialization"></a>Codec (Serialization)</h2></div></div></div><p>Since they can contain any type of payload, Exchanges are not serializable by design. It is converted into a byte array to be stored in a database BLOB field. All those conversions are handled by the <code class="literal">JdbcCodec</code> class. One detail of the code requires your attention: the <code class="literal">ClassLoadingAwareObjectInputStream</code>.</p><p>The <code class="literal">ClassLoadingAwareObjectInputStream</code> has been reused from the <a class="link" href="http://activemq.apache.org/" target="_top">Apache ActiveMQ</a> project. It wraps an <code class="literal">ObjectInputStream</code> and use it with the <code class="literal">ContextClassLoader</code> rather than the <code class="literal">currentThread</code> one. The benefit is to be able to load classes exposed by other bundles. This allows the exchange body and headers to have custom types object references.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-SQLComponent_HSH_Transaction"></a>Transaction</h2></div></div></div><p>A Spring <code class="literal">PlatformTransactionManager</code> is required to orchestrate transaction.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-SQLComponent_HSH_ServiceStartStop"></a>Service (Start/Stop)</h2></div></div></div><p>The <code class="literal">start</code> method verify the connection of the database and the presence of the required tables. If anything is wrong it will fail during starting.</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-SQLComponent_HSH_Aggregatorconfiguration"></a>Aggregator configuration</h2></div></div></div><p>Depending on the targeted environment, the aggregator might need some configuration. As you already know, each aggregator should have its own repository (with the corresponding pair of table created in the database) and a data source. If the default lobHandler is not adapted to your database system, it can be injected with the <code class="literal">lobHandler</code> property.</p><p>Here is the declaration for Oracle:</p><pre class="programlisting">    &lt;bean id="lobHandler" class="org.springframework.jdbc.support.lob.OracleLobHandler"&gt;
        &lt;property name="nativeJdbcExtractor" ref="nativeJdbcExtractor"/&gt;
    &lt;/bean&gt;

    &lt;bean id="nativeJdbcExtractor" class="org.springframework.jdbc.support.nativejdbc.CommonsDbcpNativeJdbcExtractor"/&gt;

    &lt;bean id="repo" class="org.apache.camel.processor.aggregate.jdbc.JdbcAggregationRepository"&gt;
        &lt;property name="transactionManager" ref="transactionManager"/&gt;
        &lt;property name="repositoryName" value="aggregation"/&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
        &lt;!-- Only with Oracle, else use default --&gt;
        &lt;property name="lobHandler" ref="lobHandler"/&gt;
    &lt;/bean&gt;</pre></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IDU-SQLComponent_HSH_Optimisticklocking"></a>Optimistic locking</h2></div></div></div><p>From <span class="bold"><strong>Camel 2.12</strong></span> onwards you can turn on <code class="literal">optimisticLocking</code> and use this JDBC based aggregation repository in a clustered environment where multiple Camel applications shared the same database for the aggregation repository. If there is a race condition there JDBC driver will throw a vendor specific exception which the <code class="literal">JdbcAggregationRepository</code> can react upon. To know which caused exceptions from the JDBC driver is regarded as an optimistick locking error we need a mapper to do this. Therefore there is a <code class="literal">org.apache.camel.processor.aggregate.jdbc.JdbcOptimisticLockingExceptionMapper</code> allows you to implement your custom logic if needed. There is a default implementation <code class="literal">org.apache.camel.processor.aggregate.jdbc.DefaultJdbcOptimisticLockingExceptionMapper</code> which works as follows:</p><p>The following check is done:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>If the caused exception is an <code class="literal">SQLException</code> then the SQLState is checked if starts with 23.</p></li><li class="listitem"><p>If the caused exception is a <code class="literal">DataIntegrityViolationException</code>
        </p></li><li class="listitem"><p>If the caused exception class name has "ConstraintViolation" in its name.</p></li><li class="listitem"><p>optional checking for FQN class name matches if any class names has been configured</p></li></ul></div><p>You can in addition add FQN classnames, and if any of the caused exception (or any nested) equals any of the FQN class names, then its an optimistick locking error.</p><p>Here is an example, where we define 2 extra FQN class names from the JDBC vendor.</p><pre class="programlisting">    &lt;bean id="repo" class="org.apache.camel.processor.aggregate.jdbc.JdbcAggregationRepository"&gt;
        &lt;property name="transactionManager" ref="transactionManager"/&gt;
        &lt;property name="repositoryName" value="aggregation"/&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
        &lt;property name"jdbcOptimisticLockingExceptionMapper" ref="myExceptionMapper"/&gt;
    &lt;/bean&gt;

    &lt;!-- use the default mapper with extra FQN class names from our JDBC driver --&gt;
    &lt;bean id="myExceptionMapper" class="org.apache.camel.processor.aggregate.jdbc.DefaultJdbcOptimisticLockingExceptionMapper"&gt;
      &lt;property name="classNames"&gt;
        &lt;util:set&gt;
          &lt;value&gt;com.foo.sql.MyViolationExceptoion&lt;/value&gt;
          &lt;value&gt;com.foo.sql.MyOtherViolationExceptoion&lt;/value&gt;
        &lt;/util:set&gt;
      &lt;/property&gt;
    &lt;/bean&gt;</pre><p>See also:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a href="IDU-JDBC.html" class="olink">JDBC</a>
        </p></li></ul></div></div></div></body></html>