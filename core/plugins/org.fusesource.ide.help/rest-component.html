<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>REST Component</title><link rel="stylesheet" type="text/css" href="eclipse_book.css"><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"><link rel="home" href="index.html" title="Red Hat Fuse Tooling"><link rel="up" href="IDU-Components.html" title="Part&nbsp;V.&nbsp;Apache Camel Component Reference"><link rel="prev" href="ref-component.html" title="Ref Component"><link rel="next" href="rest-swagger-component.html" title="REST Swagger Component"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="rest-component"></a>REST Component</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="rest-component.html#_uri_format_160">URI format</a></span></dt><dt><span class="section"><a href="rest-component.html#_uri_options_46">URI Options</a></span></dt><dt><span class="section"><a href="rest-component.html#_supported_rest_components">Supported rest components</a></span></dt><dt><span class="section"><a href="rest-component.html#_path_and_uritemplate_syntax">Path and uriTemplate syntax</a></span></dt><dt><span class="section"><a href="rest-component.html#_rest_producer_examples">Rest producer examples</a></span></dt><dt><span class="section"><a href="rest-component.html#_rest_producer_binding">Rest producer binding</a></span></dt><dt><span class="section"><a href="rest-component.html#_more_examples_2">More examples</a></span></dt><dt><span class="section"><a href="rest-component.html#_see_also_107">See Also</a></span></dt></dl></div><p><span class="strong"><strong>Available as of Camel version 2.14</strong></span></p><p>The rest component allows to define REST endpoints (consumer) using the
Rest DSL and plugin to other Camel components as the
REST transport.</p><p>From Camel 2.18 onwards the rest component can also be used as a client (producer) to call REST services.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_uri_format_160"></a>URI format</h2></div></div></div><pre class="screen">rest://method:path[:uriTemplate]?[options]</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_uri_options_46"></a>URI Options</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="rest-component.html#_path_parameters_3_parameters_13">Path Parameters (3 parameters):</a></span></dt><dt><span class="section"><a href="rest-component.html#_query_parameters_15_parameters_3">Query Parameters (15 parameters):</a></span></dt></dl></div><p>The REST component supports 4 options which are listed below.</p><div class="informaltable"><table border="1" width="100%"><colgroup><col width="19%" class="col_1"><col width="51%" class="col_2"><col width="10%" class="col_3"><col width="20%" class="col_4"></colgroup><thead><tr><th align="left" valign="top">Name</th><th align="left" valign="top">Description</th><th align="center" valign="top">Default</th><th align="left" valign="top">Type</th></tr></thead><tbody><tr><td align="left" valign="top"><p><span class="strong"><strong>componentName</strong></span> (common)</p></td><td align="left" valign="top"><p>The Camel Rest component to use for the REST transport, such as restlet, spark-rest. If no component has been explicit configured, then Camel will lookup if there is a Camel component that integrates with the Rest DSL, or if a org.apache.camel.spi.RestConsumerFactory (consumer) or org.apache.camel.spi.RestProducerFactory (producer) is registered in the registry. If either one is found, then that is being used.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>apiDoc</strong></span> (producer)</p></td><td align="left" valign="top"><p>The swagger api doc resource to use. The resource is loaded from classpath by default and must be in JSon format.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>host</strong></span> (producer)</p></td><td align="left" valign="top"><p>Host and port of HTTP service to use (override host in swagger schema)</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>resolveProperty Placeholders</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.</p></td><td align="center" valign="top"><p>true</p></td><td align="left" valign="top"><p>boolean</p></td></tr></tbody></table></div><p>The REST endpoint is configured using URI syntax:</p><pre class="screen">rest:method:path:uriTemplate</pre><p>with the following path and query parameters:</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_path_parameters_3_parameters_13"></a>Path Parameters (3 parameters):</h3></div></div></div><div class="informaltable"><table border="1" width="100%"><colgroup><col width="19%" class="col_1"><col width="51%" class="col_2"><col width="10%" class="col_3"><col width="20%" class="col_4"></colgroup><thead><tr><th align="left" valign="top">Name</th><th align="left" valign="top">Description</th><th align="center" valign="top">Default</th><th align="left" valign="top">Type</th></tr></thead><tbody><tr><td align="left" valign="top"><p><span class="strong"><strong>method</strong></span></p></td><td align="left" valign="top"><p><span class="strong"><strong>Required</strong></span> HTTP method to use.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>path</strong></span></p></td><td align="left" valign="top"><p><span class="strong"><strong>Required</strong></span> The base path</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>uriTemplate</strong></span></p></td><td align="left" valign="top"><p>The uri template</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_query_parameters_15_parameters_3"></a>Query Parameters (15 parameters):</h3></div></div></div><div class="informaltable"><table border="1" width="100%"><colgroup><col width="19%" class="col_1"><col width="51%" class="col_2"><col width="10%" class="col_3"><col width="20%" class="col_4"></colgroup><thead><tr><th align="left" valign="top">Name</th><th align="left" valign="top">Description</th><th align="center" valign="top">Default</th><th align="left" valign="top">Type</th></tr></thead><tbody><tr><td align="left" valign="top"><p><span class="strong"><strong>componentName</strong></span> (common)</p></td><td align="left" valign="top"><p>The Camel Rest component to use for the REST transport, such as restlet, spark-rest. If no component has been explicit configured, then Camel will lookup if there is a Camel component that integrates with the Rest DSL, or if a org.apache.camel.spi.RestConsumerFactory is registered in the registry. If either one is found, then that is being used.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>consumes</strong></span> (common)</p></td><td align="left" valign="top"><p>Media type such as: 'text/xml', or 'application/json' this REST service accepts. By default we accept all kinds of types.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>inType</strong></span> (common)</p></td><td align="left" valign="top"><p>To declare the incoming POJO binding type as a FQN class name</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>outType</strong></span> (common)</p></td><td align="left" valign="top"><p>To declare the outgoing POJO binding type as a FQN class name</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>produces</strong></span> (common)</p></td><td align="left" valign="top"><p>Media type such as: 'text/xml', or 'application/json' this REST service returns.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>routeId</strong></span> (common)</p></td><td align="left" valign="top"><p>Name of the route this REST services creates</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>bridgeErrorHandler</strong></span> (consumer)</p></td><td align="left" valign="top"><p>Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN/ERROR level and ignored.</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>description</strong></span> (consumer)</p></td><td align="left" valign="top"><p>Human description to document this REST service</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>exceptionHandler</strong></span> (consumer)</p></td><td align="left" valign="top"><p>To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this options is not in use. By default the consumer will deal with exceptions, that will be logged at WARN/ERROR level and ignored.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>ExceptionHandler</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>exchangePattern</strong></span> (consumer)</p></td><td align="left" valign="top"><p>Sets the default exchange pattern when creating an exchange.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>ExchangePattern</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>apiDoc</strong></span> (producer)</p></td><td align="left" valign="top"><p>The swagger api doc resource to use. The resource is loaded from classpath by default and must be in JSon format.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>bindingMode</strong></span> (producer)</p></td><td align="left" valign="top"><p>Configures the binding mode for the producer. If set to anything other than 'off' the producer will try to convert the body of the incoming message from inType to the json or xml, and the response from json or xml to outType.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>RestBindingMode</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>host</strong></span> (producer)</p></td><td align="left" valign="top"><p>Host and port of HTTP service to use (override host in swagger schema)</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>queryParameters</strong></span> (producer)</p></td><td align="left" valign="top"><p>Query parameters for the HTTP service to call</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>synchronous</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_supported_rest_components"></a>Supported rest components</h2></div></div></div><p>The following components support rest consumer (Rest DSL):</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">camel-coap</li><li class="listitem">camel-netty-http</li><li class="listitem">camel-netty4-http</li><li class="listitem">camel-jetty</li><li class="listitem">camel-restlet</li><li class="listitem">camel-servlet</li><li class="listitem">camel-spark-rest</li><li class="listitem">camel-undertow</li></ul></div><p>The following components support rest producer:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">camel-http</li><li class="listitem">camel-http4</li><li class="listitem">camel-netty4-http</li><li class="listitem">camel-jetty</li><li class="listitem">camel-restlet</li><li class="listitem">camel-undertow</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_path_and_uritemplate_syntax"></a>Path and uriTemplate syntax</h2></div></div></div><p>The path and uriTemplate option is defined using a REST syntax where you
define the REST context path using support for parameters.&nbsp;</p><p>TIP:If no uriTemplate is configured then path option works the same way. It
does not matter if you configure only path or if you configure both
options. Though configuring both a path and uriTemplate is a more common
practice with REST.</p><p>The following is a Camel route using a a path only</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"rest:get:hello"</em></strong>)
  .transform().constant(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"Bye World"</em></strong>);</pre><p>And the following route uses a parameter which is mapped to a Camel
header with the key "me".</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"rest:get:hello/{me}"</em></strong>)
  .transform().simple(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"Bye ${header.me}"</em></strong>);</pre><p>The following examples have configured a base path as "hello" and then
have two REST services configured using uriTemplates.</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"rest:get:hello:/{me}"</em></strong>)
  .transform().simple(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"Hi ${header.me}"</em></strong>);

from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"rest:get:hello:/french/{me}"</em></strong>)
  .transform().simple(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"Bonjour ${header.me}"</em></strong>);</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_rest_producer_examples"></a>Rest producer examples</h2></div></div></div><p>You can use the rest component to call REST services like any other Camel component.</p><p>For example to call a REST service on using <code class="literal">hello/{me}</code> you can do</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"direct:start"</em></strong>)
  .to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"rest:get:hello/{me}"</em></strong>);</pre><p>And then the dynamic value <code class="literal">{me}</code> is mapped to Camel message with the same name.
So to call this REST service you can send an empty message body and a header as shown:</p><pre class="programlisting">template.sendBodyAndHeader(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"direct:start"</em></strong>, null, <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"me"</em></strong>, <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"Donald Duck"</em></strong>);</pre><p>The Rest producer needs to know the hostname and port of the REST service, which you can configure
using the host option as shown:</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"direct:start"</em></strong>)
  .to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"rest:get:hello/{me}?host=myserver:8080/foo"</em></strong>);</pre><p>Instead of using the host option, you can configure the host on the <code class="literal">restConfiguration</code> as shown:</p><pre class="programlisting">restConfiguration().host(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"myserver:8080/foo"</em></strong>);

from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"direct:start"</em></strong>)
  .to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"rest:get:hello/{me}"</em></strong>);</pre><p>You can use the <code class="literal">producerComponent</code> to select which Camel component to use as the HTTP client, for example
to use http4 you can do:</p><pre class="programlisting">restConfiguration().host(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"myserver:8080/foo"</em></strong>).producerComponent(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"http4"</em></strong>);

from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"direct:start"</em></strong>)
  .to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"rest:get:hello/{me}"</em></strong>);</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_rest_producer_binding"></a>Rest producer binding</h2></div></div></div><p>The REST producer supports binding using JSon or XML like the rest-dsl does.</p><p>For example to use jetty with json binding mode turned on you can configure this in the rest configuration:</p><pre class="programlisting">restConfiguration().component(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"jetty"</em></strong>).host(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"localhost"</em></strong>).port(<span xmlns="http://www.w3.org/1999/xhtml" class="hl-number">8080</span>).bindingMode(RestBindingMode.json);

from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"direct:start"</em></strong>)
  .to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"rest:post:user"</em></strong>);</pre><p>Then when calling the REST service using rest producer it will automatic bind any POJOs to json before calling the REST service:</p><pre class="programlisting">  UserPojo user = <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">new</strong> UserPojo();
  user.setId(<span xmlns="http://www.w3.org/1999/xhtml" class="hl-number">123</span>);
  user.setName(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"Donald Duck"</em></strong>);

  template.sendBody(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"direct:start"</em></strong>, user);</pre><p>In the example above we send a POJO instance <code class="literal">UserPojo</code> as the message body. And because we have turned on JSon binding
in the rest configuration, then the POJO will be marshalled from POJO to JSon before calling the REST service.</p><p>However if you want to also perform binding for the response message (eg what the REST service send back as response) you
would need to configure the <code class="literal">outType</code> option to specify what is the classname of the POJO to unmarshal from JSon to POJO.</p><p>For example if the REST service returns a JSon payload that binds to <code class="literal">com.foo.MyResponsePojo</code> you can configure this as shown:</p><pre class="programlisting">  restConfiguration().component(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"jetty"</em></strong>).host(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"localhost"</em></strong>).port(<span xmlns="http://www.w3.org/1999/xhtml" class="hl-number">8080</span>).bindingMode(RestBindingMode.json);

  from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"direct:start"</em></strong>)
    .to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"rest:post:user?outType=com.foo.MyResponsePojo"</em></strong>);</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="imagesdb/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>You must configure <code class="literal">outType</code> option if you want POJO binding to happen for the response messages received from calling the REST service.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_more_examples_2"></a>More examples</h2></div></div></div><p>See&nbsp;Rest DSL&nbsp;which offers more examples and how you
can use the Rest DSL to define those in a nicer RESTful way.</p><p>There is a <span class="strong"><strong>camel-example-servlet-rest-tomcat</strong></span> example in the Apache
Camel distribution, that demonstrates how to use the
Rest DSL with SERVLET&nbsp;as
transport&nbsp;that can be deployed on Apache Tomcat, or similar web
containers.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_see_also_107"></a>See Also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Rest DSL</li><li class="listitem"><a class="link" href="servlet-component.html" title="Servlet Component">SERVLET</a></li></ul></div></div></div></body></html>