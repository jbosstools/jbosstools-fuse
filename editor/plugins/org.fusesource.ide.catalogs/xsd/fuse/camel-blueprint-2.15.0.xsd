<?xml version="1.0" encoding="UTF-8"?><xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:tns="http://camel.apache.org/schema/blueprint" elementFormDefault="qualified" targetNamespace="http://camel.apache.org/schema/blueprint" version="1.0">

  <xs:element name="aggregate" type="tns:aggregateDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Aggregates many messages into a single message</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="aop" type="tns:aopDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Does processing before and/or after the route is completed</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="avro" type="tns:avroDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">Avro data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="barcode" type="tns:barcodeDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">Barcode data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="base64" type="tns:base64DataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">Base64 data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="batch-config" type="tns:batchResequencerConfig">
    <xs:annotation>
      <xs:documentation xml:lang="en">Configures batch-processing resequence eip.</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="bean" type="tns:beanDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Calls a java bean</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="beanio" type="tns:beanioDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">BeanIO data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="bindy" type="tns:bindyDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">Bindy data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="camelContext" type="tns:camelContextFactoryBean"/>

  <xs:element name="castor" type="tns:castorDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">Castor data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="choice" type="tns:choiceDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Routes messages based on a series of predicates</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="circuitBreaker" type="tns:circuitBreakerLoadBalancerDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Circuit break load balancer</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="constant" type="tns:constantExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">For expressions and predicates using a constant</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="consumerTemplate" type="tns:camelConsumerTemplateFactoryBean"/>

  <xs:element name="contextScan" type="tns:contextScanDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Scans for Java org.apache.camel.builder.RouteBuilder instances in the context org.apache.camel.spi.Registry.</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="convertBodyTo" type="tns:convertBodyDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Converts the message body to another type</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="crypto" type="tns:cryptoDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">Crypto data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="csv" type="tns:csvDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">CSV data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="customDataFormat" type="tns:customDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">Custom data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="customLoadBalancer" type="tns:customLoadBalancerDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Custom load balancer</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="dataFormats" type="tns:dataFormatsDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">To configure data formats</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="delay" type="tns:delayDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Delays processing for a specified length of time</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="delete" type="tns:deleteVerbDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Rest DELETE command</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="description" type="tns:descriptionDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">To provide comments about the node.</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="doCatch" type="tns:catchDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Catches exceptions as part of a try catch finally block</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="doFinally" type="tns:finallyDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Path traversed when a try catch finally block exits</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="doTry" type="tns:tryDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Marks the beginning of a try catch finally block</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="dynamicRouter" type="tns:dynamicRouterDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Routes messages based on dynamic rules</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="el" type="tns:elExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">For EL expressions and predicates</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="endpoint" type="tns:camelEndpointFactoryBean"/>

  <xs:element name="enrich" type="tns:enrichDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Enriches a message with data from a secondary resource</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="errorHandler" type="tns:camelErrorHandlerFactoryBean"/>

  <xs:element name="exchangeProperty" type="tns:exchangePropertyExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">An expression which extracts the named exchange property</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="export" type="tns:camelServiceExporterDefinition"/>

  <xs:element name="expression" type="tns:expressionSubElementDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">A useful base class for an expression</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="expressionDefinition" type="tns:expression"/>

  <xs:element name="failover" type="tns:failoverLoadBalancerDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Failover load balancer</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="filter" type="tns:filterDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Filter out messages based using a predicate</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="flatpack" type="tns:flatpackDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">Flatpack data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="from" type="tns:fromDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Act as a message source as input to a route</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="get" type="tns:getVerbDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Rest GET command</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="groovy" type="tns:groovyExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">For Groovy expressions and predicates</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="gzip" type="tns:gzipDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">GZip data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="head" type="tns:headVerbDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Rest HEAD command</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="header" type="tns:headerExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">An expression which extracts the named exchange header</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="hl7" type="tns:hl7DataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">HL7 data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="ical" type="tns:icalDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">iCal data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="idempotentConsumer" type="tns:idempotentConsumerDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Filters out duplicate messages</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="inOnly" type="tns:inOnlyDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Marks the exchange pattern for the route to one way</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="inOut" type="tns:inOutDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Marks the exchange pattern for the route to request/reply</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="intercept" type="tns:interceptDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Intercepts a message at each step in the route</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="interceptFrom" type="tns:interceptFromDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Intercepts incoming messages</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="interceptSendToEndpoint" type="tns:interceptSendToEndpointDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Intercepts messages being sent to an endpoint</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="javaScript" type="tns:javaScriptExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">For JavaScript expressions and predicates</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="jaxb" type="tns:jaxbDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">JAXB data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="jibx" type="tns:jibxDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">JiBX data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="jmxAgent" type="tns:camelJMXAgentDefinition"/>

  <xs:element name="json" type="tns:jsonDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">Json data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="jsonpath" type="tns:jsonPathExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">For JSonPath expressions and predicates</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="jxpath" type="tns:jxPathExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">For JXPath expressions and predicates</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="keyStoreParameters" type="tns:keyStoreParametersFactoryBean"/>

  <xs:element name="language" type="tns:languageExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">Represents a parameterised language expression which can support any language at runtime using the language attribute.</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="loadBalance" type="tns:loadBalanceDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Balances message processing among a number of nodes</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="log" type="tns:logDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Logs the defined message to the logger</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="loop" type="tns:loopDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Processes a message multiple times</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="marshal" type="tns:marshalDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Marshals data into a specified format for transmission over a transport or component</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="method" type="tns:methodCallExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">For expressions and predicates using a java bean (aka method call)</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="multicast" type="tns:multicastDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Routes the same message to multiple paths either sequentially or in parallel.</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="mvel" type="tns:mvelExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">For MVEL expressions and predicates</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="ognl" type="tns:ognlExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">For OGNL expressions and predicates</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="onCompletion" type="tns:onCompletionDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Route to be executed when normal route processing completes</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="onException" type="tns:onExceptionDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Route to be executed when an exception is thrown</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="optimisticLockRetryPolicy" type="tns:optimisticLockRetryPolicyDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">To configure optimistic locking</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="otherwise" type="tns:otherwiseDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Route to be executed when all other choices evaluate to false</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="packageScan" type="tns:packageScanDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Scans for Java org.apache.camel.builder.RouteBuilder classes in java packages</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="pgp" type="tns:pgpDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">PGP data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="php" type="tns:phpExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">For PHP expressions and predicates</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="pipeline" type="tns:pipelineDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Routes the message to a sequence of processors.</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="policy" type="tns:policyDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Defines a policy the route will use</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="pollEnrich" type="tns:pollEnrichDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Enriches messages with data polled from a secondary resource</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="post" type="tns:postVerbDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Rest POST command</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="process" type="tns:processDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Calls a Camel processor.</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="properties" type="tns:propertiesDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">A series of key value pair</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="propertiesFunction" type="tns:camelPropertyPlaceholderFunctionDefinition"/>

  <xs:element name="property" type="tns:propertyDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">A key value pair</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="propertyPlaceholder" type="tns:camelPropertyPlaceholderDefinition"/>

  <xs:element name="protobuf" type="tns:protobufDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">Google protobuf data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="proxy" nillable="true" type="xs:anyType"/>

  <xs:element name="put" type="tns:putVerbDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Rest PUT command</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="python" type="tns:pythonExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">For Python expressions and predicates</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="random" type="tns:randomLoadBalancerDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Random load balancer</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="recipientList" type="tns:recipientListDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Routes messages to a number of dynamically specified recipients (dynamic to)</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="redeliveryPolicy" type="tns:redeliveryPolicyDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">To configure re-delivery for error handling</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="redeliveryPolicyProfile" type="tns:camelRedeliveryPolicyFactoryBean"/>

  <xs:element name="ref" type="tns:refExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">For using a custom expression</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="removeHeader" type="tns:removeHeaderDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Removes a named header from the message</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="removeHeaders" type="tns:removeHeadersDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Removes message headers whose name matches a specified pattern</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="removeProperties" type="tns:removePropertiesDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Removes message exchange properties whose name matches a specified pattern</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="removeProperty" type="tns:removePropertyDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Removes a named property from the message exchange</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="resequence" type="tns:resequenceDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Resequences (re-order) messages based on an expression</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="rest" type="tns:restDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Defines a rest service using the rest-dsl</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="restBinding" type="tns:restBindingDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">To configure rest binding</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="restConfiguration" type="tns:restConfigurationDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">To configure rest</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="restContext" type="tns:camelRestContextFactoryBean"/>

  <xs:element name="restContextRef" type="tns:restContextRefDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">To refer to an XML file with rest services defined using the rest-dsl</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="restProperty" type="tns:restPropertyDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">A key value pair</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="rests" type="tns:restsDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">A series of rest services defined using the rest-dsl</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="rollback" type="tns:rollbackDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Forces a rollback by stopping routing the message</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="roundRobin" type="tns:roundRobinLoadBalancerDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Round robin load balancer</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="route" type="tns:routeDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">A Camel route</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="routeBuilder" type="tns:routeBuilderDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">To refer to a Java org.apache.camel.builder.RouteBuilder instance to use.</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="routeContext" type="tns:camelRouteContextFactoryBean"/>

  <xs:element name="routeContextRef" type="tns:routeContextRefDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">To refer to an XML file with routes defined using the xml-dsl</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="routes" type="tns:routesDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">A series of Camel routes</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="routingSlip" type="tns:routingSlipDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Routes a message through a series of steps that are pre-determined (the slip)</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="rss" type="tns:rssDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">RSS data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="ruby" type="tns:rubyExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">For Ruby expressions and predicates</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="sample" type="tns:samplingDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Extract a sample of the messages passing through a route</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="secureRandomParameters" type="tns:secureRandomParametersFactoryBean"/>

  <xs:element name="secureXML" type="tns:xmlSecurityDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">xml-security data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="serialization" type="tns:serializationDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">Java Object Serialization data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="setBody" type="tns:setBodyDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Sets the contents of the message body</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="setExchangePattern" type="tns:setExchangePatternDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Sets the exchange pattern on the message exchange</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="setFaultBody" type="tns:setFaultBodyDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Sets the contents of a fault message's body</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="setHeader" type="tns:setHeaderDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Sets the value of a message header</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="setOutHeader" type="tns:setOutHeaderDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Sets the value of a header on the outbound message</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="setProperty" type="tns:setPropertyDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Sets a named property on the message exchange</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="simple" type="tns:simpleExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">For expressions and predicates using the simple language</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="soapjaxb" type="tns:soapJaxbDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">SOAP data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="sort" type="tns:sortDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Sorts the contents of the message</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="spel" type="tns:spELExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">For Spring Expression Language (SpEL) expressions and predicates</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="split" type="tns:splitDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Splits a single message into many sub-messages.</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="sql" type="tns:sqlExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">For SQL expressions and predicates</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="sslContextParameters" type="tns:sslContextParametersFactoryBean"/>

  <xs:element name="sticky" type="tns:stickyLoadBalancerDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Sticky load balancer</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="stop" type="tns:stopDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Stops the processing of the current message</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="stream-config" type="tns:streamResequencerConfig">
    <xs:annotation>
      <xs:documentation xml:lang="en">Configures stream-processing resequence eip.</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="streamCaching" type="tns:camelStreamCachingStrategyDefinition"/>

  <xs:element name="string" type="tns:stringDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">Represents the String (text based) DataFormat</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="syslog" type="tns:syslogDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">Syslog data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="template" type="tns:camelProducerTemplateFactoryBean"/>

  <xs:element name="terser" type="tns:terserExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">For HL7 terser expressions and predicates</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="threadPool" type="tns:camelThreadPoolFactoryBean"/>

  <xs:element name="threadPoolProfile" type="tns:threadPoolProfileDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">To configure thread pools</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="threads" type="tns:threadsDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Specifies that all steps after this node are processed asynchronously</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="throttle" type="tns:throttleDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Controls the rate at which messages are passed to the next node in the route</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="throwException" type="tns:throwExceptionDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Throws an exception</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="tidyMarkup" type="tns:tidyMarkupDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">Tidymark (wellformed HTML) data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="to" type="tns:toDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Sends the message to an endpoint</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="tokenize" type="tns:tokenizerExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">For expressions and predicates using a body or header tokenizer.</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="topic" type="tns:topicLoadBalancerDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Topic load balancer</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="transacted" type="tns:transactedDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Enables transaction on the route</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="transform" type="tns:transformDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Transforms the message body based on an expression</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="univocity-csv" type="tns:uniVocityCsvDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">UniVocity CSV data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="univocity-fixed" type="tns:uniVocityFixedWidthDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">UniVocity fixed-width data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="univocity-header" type="tns:uniVocityHeader">
    <xs:annotation>
      <xs:documentation xml:lang="en">To configure headers for UniVocity data formats.</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="univocity-tsv" type="tns:uniVocityTsvDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">UniVocity TSV data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="unmarshal" type="tns:unmarshalDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Converts the message data received from the wire into a format that Apache Camel processors can consume</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="validate" type="tns:validateDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Validates a message based on an expression</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="verb" type="tns:verbDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Rest command</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="vtdxml" type="tns:vtdXmlExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">For VTD-XML (fast and efficient XPath) expressions and predicates</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="weighted" type="tns:weightedLoadBalancerDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Weighted load balancer</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="when" type="tns:whenDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Triggers a route when an expression evaluates to true</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="whenSkipSendToEndpoint" type="tns:whenSkipSendToEndpointDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Predicate to determine if the message should be sent or not to the endpoint when using interceptSentToEndpoint.</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="wireTap" type="tns:wireTapDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en">Routes a copy of a message (or creates a new message) to a secondary destination while continue routing the original message.</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="xmlBeans" type="tns:xmlBeansDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">XMLBeans data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="xmljson" type="tns:xmlJsonDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">xml-json data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="xmlrpc" type="tns:xmlRpcDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">xml-rpc data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="xpath" type="tns:xPathExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">For XPath expressions and predicates</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="xquery" type="tns:xQueryExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">For XQuery expressions and predicates</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="xstream" type="tns:xStreamDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">xstream data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="xtokenize" type="tns:xmlTokenizerExpression">
    <xs:annotation>
      <xs:documentation xml:lang="en">For expressions and predicates using a body or header tokenizer.</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="zip" type="tns:zipDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">zip data format (not for zip files)</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="zipFile" type="tns:zipFileDataFormat">
    <xs:annotation>
      <xs:documentation xml:lang="en">zip-file data format</xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:complexType name="camelConsumerTemplateFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelConsumerTemplateFactoryBean">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="abstractCamelConsumerTemplateFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelFactoryBean">
        <xs:sequence/>
        <xs:attribute name="maximumCacheSize" type="xs:int"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="abstractCamelFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="camelContextId" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="identifiedType">
    <xs:sequence/>
    <xs:attribute name="id" type="xs:ID">
      <xs:annotation>
        <xs:documentation xml:lang="en">Sets the value of the id property.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="camelContextFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelContextFactoryBean">
        <xs:sequence>
          <xs:element minOccurs="0" ref="tns:properties"/>
          <xs:element minOccurs="0" ref="tns:propertyPlaceholder"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="package" type="xs:string"/>
          <xs:element minOccurs="0" ref="tns:packageScan"/>
          <xs:element minOccurs="0" ref="tns:contextScan"/>
          <xs:element minOccurs="0" ref="tns:jmxAgent"/>
          <xs:element minOccurs="0" ref="tns:streamCaching"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:template"/>
            <xs:element ref="tns:consumerTemplate"/>
            <xs:element ref="tns:proxy"/>
            <xs:element ref="tns:export"/>
            <xs:element ref="tns:errorHandler"/>
          </xs:choice>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:routeBuilder"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:routeContextRef"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:restContextRef"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:threadPoolProfile"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:threadPool"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:endpoint"/>
          <xs:element minOccurs="0" ref="tns:dataFormats"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:redeliveryPolicyProfile"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:onException"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:onCompletion"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:intercept"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:interceptFrom"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:interceptSendToEndpoint"/>
          <xs:element minOccurs="0" ref="tns:restConfiguration"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:rest"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:route"/>
        </xs:sequence>
        <xs:attribute name="depends-on" type="xs:string"/>
        <xs:attribute name="trace" type="xs:string"/>
        <xs:attribute name="messageHistory" type="xs:string"/>
        <xs:attribute name="streamCache" type="xs:string"/>
        <xs:attribute name="delayer" type="xs:string"/>
        <xs:attribute name="handleFault" type="xs:string"/>
        <xs:attribute name="errorHandlerRef" type="xs:string"/>
        <xs:attribute name="autoStartup" type="xs:string"/>
        <xs:attribute name="useMDCLogging" type="xs:string"/>
        <xs:attribute name="useBreadcrumb" type="xs:string"/>
        <xs:attribute name="allowUseOriginalMessage" type="xs:string"/>
        <xs:attribute name="runtimeEndpointRegistryEnabled" type="xs:string"/>
        <xs:attribute name="managementNamePattern" type="xs:string"/>
        <xs:attribute name="threadNamePattern" type="xs:string"/>
        <xs:attribute name="useBlueprintPropertyResolver" type="xs:boolean"/>
        <xs:attribute name="shutdownRoute" type="tns:shutdownRoute"/>
        <xs:attribute name="shutdownRunningTask" type="tns:shutdownRunningTask"/>
        <xs:attribute name="lazyLoadTypeConverters" type="xs:boolean"/>
        <xs:attribute name="typeConverterStatisticsEnabled" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="abstractCamelContextFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="propertiesDefinition">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:property"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="propertyDefinition">
    <xs:sequence/>
    <xs:attribute name="key" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Property key</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Property value</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="camelPropertyPlaceholderDefinition">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:propertiesFunction"/>
        </xs:sequence>
        <xs:attribute name="location" type="xs:string" use="required"/>
        <xs:attribute name="cache" type="xs:boolean"/>
        <xs:attribute name="ignoreMissingLocation" type="xs:boolean"/>
        <xs:attribute name="propertiesResolverRef" type="xs:string"/>
        <xs:attribute name="propertiesParserRef" type="xs:string"/>
        <xs:attribute name="propertyPrefix" type="xs:string"/>
        <xs:attribute name="propertySuffix" type="xs:string"/>
        <xs:attribute name="fallbackToUnaugmentedProperty" type="xs:boolean"/>
        <xs:attribute name="prefixToken" type="xs:string"/>
        <xs:attribute name="suffixToken" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelPropertyPlaceholderFunctionDefinition">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="packageScanDefinition">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" name="package" type="xs:string"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="excludes" type="xs:string"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="includes" type="xs:string"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="contextScanDefinition">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="excludes" type="xs:string"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="includes" type="xs:string"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="camelJMXAgentDefinition">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="disabled" type="xs:string"/>
        <xs:attribute name="onlyRegisterProcessorWithCustomId" type="xs:string"/>
        <xs:attribute name="registryPort" type="xs:string"/>
        <xs:attribute name="connectorPort" type="xs:string"/>
        <xs:attribute name="mbeanServerDefaultDomain" type="xs:string"/>
        <xs:attribute name="mbeanObjectDomainName" type="xs:string"/>
        <xs:attribute name="serviceUrlPath" type="xs:string"/>
        <xs:attribute name="createConnector" type="xs:string"/>
        <xs:attribute name="usePlatformMBeanServer" type="xs:string"/>
        <xs:attribute name="registerAlways" type="xs:string"/>
        <xs:attribute name="registerNewRoutes" type="xs:string"/>
        <xs:attribute name="statisticsLevel" type="xs:string"/>
        <xs:attribute name="loadStatisticsEnabled" type="xs:string"/>
        <xs:attribute name="includeHostName" type="xs:string"/>
        <xs:attribute name="mask" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelStreamCachingStrategyDefinition">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="enabled" type="xs:string"/>
        <xs:attribute name="spoolDirectory" type="xs:string"/>
        <xs:attribute name="spoolChiper" type="xs:string"/>
        <xs:attribute name="spoolThreshold" type="xs:string"/>
        <xs:attribute name="spoolUsedHeapMemoryThreshold" type="xs:string"/>
        <xs:attribute name="spoolUsedHeapMemoryLimit" type="xs:string"/>
        <xs:attribute name="spoolRules" type="xs:string"/>
        <xs:attribute name="bufferSize" type="xs:string"/>
        <xs:attribute name="removeSpoolDirectoryWhenStopping" type="xs:string"/>
        <xs:attribute name="statisticsEnabled" type="xs:string"/>
        <xs:attribute name="anySpoolRules" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelProducerTemplateFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelProducerTemplateFactoryBean">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="abstractCamelProducerTemplateFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelFactoryBean">
        <xs:sequence/>
        <xs:attribute name="defaultEndpoint" type="xs:string"/>
        <xs:attribute name="maximumCacheSize" type="xs:int"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelProxyFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelFactoryBean">
        <xs:sequence/>
        <xs:attribute name="serviceUrl" type="xs:string"/>
        <xs:attribute name="serviceRef" type="xs:string"/>
        <xs:attribute name="serviceInterface" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelServiceExporterDefinition">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="uri" type="xs:string"/>
        <xs:attribute name="serviceRef" type="xs:string"/>
        <xs:attribute name="serviceInterface" type="xs:string"/>
        <xs:attribute name="camelContextId" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelErrorHandlerFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelFactoryBean">
        <xs:sequence>
          <xs:element minOccurs="0" ref="tns:redeliveryPolicy"/>
        </xs:sequence>
        <xs:attribute name="type" type="tns:errorHandlerType"/>
        <xs:attribute name="deadLetterUri" type="xs:string"/>
        <xs:attribute name="deadLetterHandleNewException" type="xs:boolean"/>
        <xs:attribute name="level" type="tns:loggingLevel"/>
        <xs:attribute name="logName" type="xs:string"/>
        <xs:attribute name="useOriginalMessage" type="xs:boolean"/>
        <xs:attribute name="onRedeliveryRef" type="xs:string"/>
        <xs:attribute name="retryWhileRef" type="xs:string"/>
        <xs:attribute name="executorServiceRef" type="xs:string"/>
        <xs:attribute name="redeliveryPolicyRef" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="redeliveryPolicyDefinition">
    <xs:sequence/>
    <xs:attribute name="maximumRedeliveries" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Sets the maximum redeliveries x = redeliver at most x times 0 = no redeliveries -1 = redeliver forever</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="redeliveryDelay" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Sets the initial redelivery delay</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="asyncDelayedRedelivery" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Allow synchronous delayed redelivery.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="backOffMultiplier" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Sets the back off multiplier</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useExponentialBackOff" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Turn on exponential backk off</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="collisionAvoidanceFactor" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Sets the collision avoidance factor</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useCollisionAvoidance" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Turn on collision avoidance.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maximumRedeliveryDelay" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Sets the maximum delay between redelivery</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retriesExhaustedLogLevel" type="tns:loggingLevel">
      <xs:annotation>
        <xs:documentation xml:lang="en">Sets the logging level to use when retries has exhausted</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryAttemptedLogLevel" type="tns:loggingLevel">
      <xs:annotation>
        <xs:documentation xml:lang="en">Sets the logging level to use for logging retry attempts</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logRetryAttempted" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Sets whether retry attempts should be logged or not. Can be used to include or reduce verbose.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logStackTrace" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Sets whether stack traces should be logged. Can be used to include or reduce verbose.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logRetryStackTrace" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Sets whether stack traces should be logged when an retry attempt failed. Can be used to include or reduce verbose.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logHandled" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Sets whether handled exceptions should be logged or not. Can be used to include or reduce verbose.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logNewException" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Sets whether new exceptions should be logged or not. Can be used to include or reduce verbose. A new exception is an exception that was thrown while handling a previous exception.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logContinued" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Sets whether continued exceptions should be logged or not. Can be used to include or reduce verbose.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logExhausted" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Sets whether exhausted exceptions should be logged or not. Can be used to include or reduce verbose.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logExhaustedMessageHistory" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Sets whether exhausted exceptions should be logged including message history or not (supports property placeholders). Can be used to include or reduce verbose.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="disableRedelivery" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Disables redelivery (same as setting maximum redeliveries to 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="delayPattern" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Sets the delay pattern with delay intervals.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="allowRedeliveryWhileStopping" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Controls whether to allow redelivery while stopping/shutting down a route that uses error handling.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exchangeFormatterRef" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Sets the reference of the instance of org.apache.camel.spi.ExchangeFormatter to generate the log message from exchange.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="routeBuilderDefinition">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">Reference to the route builder instance</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="routeContextRefDefinition">
    <xs:sequence/>
    <xs:attribute name="ref" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Reference to the routes in the xml dsl</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="restContextRefDefinition">
    <xs:sequence/>
    <xs:attribute name="ref" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Reference to the rest-dsl</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="threadPoolProfileDefinition">
    <xs:complexContent>
      <xs:extension base="tns:optionalIdentifiedDefinition">
        <xs:sequence>
          <xs:element minOccurs="0" name="timeUnit" type="xs:string"/>
        </xs:sequence>
        <xs:attribute name="defaultProfile" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether this profile is the default thread pool profile</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="poolSize" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the core pool size</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="maxPoolSize" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the maximum pool size</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="keepAliveTime" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the keep alive time for idle threads in the pool</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="maxQueueSize" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the maximum number of tasks in the work queue. Use -1 or Integer.MAX_VALUE for an unbounded queue</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="allowCoreThreadTimeOut" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether idle core threads is allowed to timeout and therefore can shrink the pool size below the core pool size Is by default false</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="rejectedPolicy" type="tns:threadPoolRejectedPolicy">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the handler for tasks which cannot be executed by the thread pool.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="optionalIdentifiedDefinition">
    <xs:sequence>
      <xs:element minOccurs="0" ref="tns:description"/>
    </xs:sequence>
    <xs:attribute name="customId" type="xs:boolean"/>
    <xs:attribute name="id" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Sets the id of this node</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="descriptionDefinition">
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="lang" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Language such as en for english.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="layoutX" type="xs:double">
          <xs:annotation>
            <xs:documentation xml:lang="en">Layout position X</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="layoutY" type="xs:double">
          <xs:annotation>
            <xs:documentation xml:lang="en">Layout position Y</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="layoutWidth" type="xs:double">
          <xs:annotation>
            <xs:documentation xml:lang="en">Layout width</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="layoutHeight" type="xs:double">
          <xs:annotation>
            <xs:documentation xml:lang="en">Layout height</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="camelThreadPoolFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelThreadPoolFactoryBean">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="abstractCamelThreadPoolFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelFactoryBean">
        <xs:sequence/>
        <xs:attribute name="poolSize" type="xs:string" use="required"/>
        <xs:attribute name="maxPoolSize" type="xs:string"/>
        <xs:attribute name="keepAliveTime" type="xs:string"/>
        <xs:attribute name="timeUnit" type="xs:string"/>
        <xs:attribute name="maxQueueSize" type="xs:string"/>
        <xs:attribute name="allowCoreThreadTimeOut" type="xs:string"/>
        <xs:attribute name="rejectedPolicy" type="tns:threadPoolRejectedPolicy"/>
        <xs:attribute name="threadName" type="xs:string" use="required"/>
        <xs:attribute name="scheduled" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelEndpointFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelEndpointFactoryBean">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="abstractCamelEndpointFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelFactoryBean">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:property"/>
        </xs:sequence>
        <xs:attribute name="singleton" type="xs:boolean"/>
        <xs:attribute name="uri" type="xs:string" use="required"/>
        <xs:attribute name="pattern" type="tns:exchangePattern"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="dataFormatsDefinition">
    <xs:sequence>
      <xs:choice maxOccurs="unbounded" minOccurs="0">
        <xs:element ref="tns:avro"/>
        <xs:element ref="tns:barcode"/>
        <xs:element ref="tns:base64"/>
        <xs:element ref="tns:beanio"/>
        <xs:element ref="tns:bindy"/>
        <xs:element ref="tns:castor"/>
        <xs:element ref="tns:crypto"/>
        <xs:element ref="tns:csv"/>
        <xs:element name="custom" type="tns:customDataFormat"/>
        <xs:element ref="tns:flatpack"/>
        <xs:element ref="tns:gzip"/>
        <xs:element ref="tns:hl7"/>
        <xs:element ref="tns:ical"/>
        <xs:element ref="tns:jaxb"/>
        <xs:element ref="tns:jibx"/>
        <xs:element ref="tns:json"/>
        <xs:element ref="tns:protobuf"/>
        <xs:element ref="tns:rss"/>
        <xs:element ref="tns:secureXML"/>
        <xs:element ref="tns:serialization"/>
        <xs:element ref="tns:soapjaxb"/>
        <xs:element ref="tns:string"/>
        <xs:element ref="tns:syslog"/>
        <xs:element ref="tns:tidyMarkup"/>
        <xs:element ref="tns:univocity-csv"/>
        <xs:element ref="tns:univocity-fixed"/>
        <xs:element ref="tns:univocity-tsv"/>
        <xs:element ref="tns:xmlBeans"/>
        <xs:element ref="tns:xmljson"/>
        <xs:element ref="tns:xmlrpc"/>
        <xs:element ref="tns:xstream"/>
        <xs:element ref="tns:pgp"/>
        <xs:element ref="tns:zip"/>
        <xs:element ref="tns:zipFile"/>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="avroDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="instanceClassName" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">Class name to use for marshal and unmarshalling</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="dataFormat">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="barcodeDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="width" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en">Width of the barcode</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="height" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en">Height of the barcode</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="imageType" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Image type of the barcode such as png</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="barcodeFormat" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Barcode format such as QR-Code</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="base64DataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="lineLength" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en">To specific a maximum line length for the encoded data. By default 76 is used.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="lineSeparator" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The line separators to use. By default \r\n is used.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="urlSafe" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Instead of emitting '' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode operations. Decoding seamlessly handles both modes. Is by default false.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="beanioDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="mapping" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">The BeanIO mapping file. Is by default loaded from the classpath. You can prefix with file: http: or classpath: to denote from where to load the mapping file.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="streamName" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">The name of the stream to use.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ignoreUnidentifiedRecords" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to ignore unidentified records.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ignoreUnexpectedRecords" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to ignore unexpected records.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ignoreInvalidRecords" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to ignore invalid records.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="encoding" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The charset to use. Is by default the JVM platform default charset.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="bindyDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="type" type="tns:bindyType" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to use csv fixed or key value pairs mode.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="packages">
          <xs:annotation>
            <xs:documentation xml:lang="en">The java package names to scan for model classes.</xs:documentation>
          </xs:annotation>
          <xs:simpleType>
            <xs:list itemType="xs:string"/>
          </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="classType" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Name of model class to use.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="locale" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To configure a default locale to use such as us for united states. To use the JVM platform default locale then use the name default</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="castorDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="mappingFile" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Path to a Castor mapping file to load from the classpath.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="validation" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether validation is turned on or off. Is by default true.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="encoding" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Encoding to use when marshalling an Object to XML. Is by default UTF-8</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="packages">
          <xs:annotation>
            <xs:documentation xml:lang="en">Add additional packages to Castor XmlContext</xs:documentation>
          </xs:annotation>
          <xs:simpleType>
            <xs:list itemType="xs:string"/>
          </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="classes">
          <xs:annotation>
            <xs:documentation xml:lang="en">Add additional class names to Castor XmlContext</xs:documentation>
          </xs:annotation>
          <xs:simpleType>
            <xs:list itemType="xs:string"/>
          </xs:simpleType>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="cryptoDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="algorithm" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The JCE algorithm name indicating the cryptographic algorithm that will be used. Is by default DES/CBC/PKCS5Padding.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="cryptoProvider" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The name of the JCE Security Provider that should be used.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="keyRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Refers to the secret key to lookup from the register to use.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="initVectorRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Refers to a byte array containing the Initialization Vector that will be used to initialize the Cipher.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="algorithmParameterRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">A JCE AlgorithmParameterSpec used to initialize the Cipher. Will lookup the type using the given name as a java.security.spec.AlgorithmParameterSpec type.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="buffersize" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en">The size of the buffer used in the signature process.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="macAlgorithm" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The JCE algorithm name indicating the Message Authentication algorithm.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="shouldAppendHMAC" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Flag indicating that a Message Authentication Code should be calculated and appended to the encrypted data.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="inline" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Flag indicating that the configured IV should be inlined into the encrypted data stream. Is by default false.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="csvDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="header" type="xs:string"/>
        </xs:sequence>
        <xs:attribute name="formatRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The reference format to use it will be updated with the other format options the default value is CSVFormat.DEFAULT</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="formatName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The name of the format to use the default value is CSVFormat.DEFAULT</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="commentMarkerDisabled" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Disables the comment marker of the reference format.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="commentMarker" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the comment marker of the reference format.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="delimiter" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the delimiter to use. The default value is (comma)</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="escapeDisabled" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Use for disabling using escape character</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="escape" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the escape character to use</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="headerDisabled" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Use for disabling headers</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="allowMissingColumnNames" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to allow missing column names.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ignoreEmptyLines" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to ignore empty lines.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ignoreSurroundingSpaces" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to ignore surrounding spaces</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="nullStringDisabled" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Used to disable null strings</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="nullString" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the null string</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="quoteDisabled" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Used to disable quotes</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="quote" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the quote which by default is</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="recordSeparatorDisabled" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Used for disabling record separator</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="recordSeparator" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the record separator (aka new line) which by default is \r\n (CRLF)</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="skipHeaderRecord" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to skip the header record in the output</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="lazyLoad" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether the unmarshalling should produce an iterator that reads the lines on the fly or if all the lines must be read at one.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="useMaps" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether the unmarshalling should produce maps for the lines values instead of lists. It requires to have header (either defined or collected).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="recordConverterRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Refers to a custom CsvRecordConverter to lookup from the registry to use.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="customDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">Reference to the custom org.apache.camel.spi.DataFormat to lookup from the Camel registry.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="flatpackDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="parserFactoryRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">References to a custom parser factory to lookup in the registry</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="definition" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The flatpack pzmap configuration file. Can be omitted in simpler situations but its preferred to use the pzmap.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="fixed" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Delimited or fixed. Is by default false = delimited</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ignoreFirstRecord" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether the first line is ignored for delimited files (for the column headers). Is by default true.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="textQualifier" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">If the text is qualified with a char such as "</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="delimiter" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The delimiter char (could be ; or similar)</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="allowShortLines" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Allows for lines to be shorter than expected and ignores the extra characters</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ignoreExtraColumns" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Allows for lines to be longer than expected and ignores the extra characters.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="gzipDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="hl7DataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="validate" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to validate the HL7 message Is by default true.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="icalDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="validating" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to validate.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="jaxbDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="contextPath" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">Package name where your JAXB classes are located.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="schema" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To validate against an existing schema. Your can use the prefix classpath: file: or http: to specify how the resource should by resolved. You can separate multiple schema files by using the '' character.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="prettyPrint" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">To enable pretty printing output nicely formatted. Is by default false.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ignoreJAXBElement" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to ignore JAXBElement elements - only needed to be set to false in very special use-cases.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="mustBeJAXBElement" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether marhsalling must be java objects with JAXB annotations. And if not then it fails. This option can be set to false to relax that such as when the data is already in XML format.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="filterNonXmlChars" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">To ignore non xml characheters and replace them with an empty space.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="encoding" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To overrule and use a specific encoding</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="fragment" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">To turn on marshalling XML fragment trees. By default JAXB looks for XmlRootElement annotation on given class to operate on whole XML tree. This is useful but not always - sometimes generated code does not have XmlRootElement annotation sometimes you need unmarshall only part of tree. In that case you can use partial unmarshalling. To enable this behaviours you need set property partClass. Camel will pass this class to JAXB's unmarshaler.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="partClass" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Name of class used for fragment parsing. See more details at the fragment option.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="partNamespace" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">XML namespace to use for fragment parsing. See more details at the fragment option.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="namespacePrefixRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">When marshalling using JAXB or SOAP then the JAXB implementation will automatic assign namespace prefixes such as ns2 ns3 ns4 etc. To control this mapping Camel allows you to refer to a map which contains the desired mapping.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="xmlStreamWriterWrapper" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To use a custom xml stream writer.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="schemaLocation" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To define the location of the schema</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="jibxDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="unmarshallClass" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Class name to use when unmarshalling from XML to Java.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="bindingName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To use a custom binding factory</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="jsonDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="prettyPrint" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">To enable pretty printing output nicely formatted. Is by default false.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="library" type="tns:jsonLibrary">
          <xs:annotation>
            <xs:documentation xml:lang="en">Which json library to use such. Is by default xstream</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="unmarshalTypeName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Class name of the java type to use when unarmshalling</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="jsonView" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">When marshalling a POJO to JSON you might want to exclude certain fields from the JSON output. With Jackson you can use JSON views to accomplish this. This option is to refer to the class which has JsonView annotations</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="include" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">If you want to marshal a pojo to JSON and the pojo has some fields with null values. And you want to skip these null values you can set this option to NOT_NULL</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="allowJmsType" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Used for JMS users to allow the JMSType header from the JMS spec to specify a FQN classname to use to unmarshal to.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="collectionTypeName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Refers to a custom collection type to lookup in the registry to use. This option should rarely be used but allows to use different collection types than java.util.Collection based as default.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="useList" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">To unarmshal to a List of Map or a List of Pojo.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="enableJaxbAnnotationModule" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to enable the JAXB annotations module when using jackson. When enabled then JAXB annotations can be used by Jackson.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="moduleClassNames" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To use custom Jackson modules com.fasterxml.jackson.databind.Module specified as a String with FQN class names. Multiple classes can be separated by comma.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="moduleRefs" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To use custom Jackson modules referred from the Camel registry. Multiple modules can be separated by comma.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="enableFeatures" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Set of features to enable on the Jackson com.fasterxml.jackson.databind.ObjectMapper. The features should be a name that matches a enum from com.fasterxml.jackson.databind.SerializationFeature com.fasterxml.jackson.databind.DeserializationFeature or com.fasterxml.jackson.databind.MapperFeature Multiple features can be separated by comma</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="disableFeatures" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Set of features to disable on the Jackson com.fasterxml.jackson.databind.ObjectMapper. The features should be a name that matches a enum from com.fasterxml.jackson.databind.SerializationFeature com.fasterxml.jackson.databind.DeserializationFeature or com.fasterxml.jackson.databind.MapperFeature Multiple features can be separated by comma</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="protobufDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="instanceClass" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Name of class to use when unarmshalling</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="rssDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="xmlSecurityDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="xmlCipherAlgorithm" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The cipher algorithm to be used for encryption/decryption of the XML message content. The available choices are: XMLCipher.TRIPLEDES XMLCipher.AES_128 XMLCipher.AES_128_GCM XMLCipher.AES_192 XMLCipher.AES_192_GCM XMLCipher.AES_256 XMLCipher.AES_256_GCM XMLCipher.SEED_128 XMLCipher.CAMELLIA_128 XMLCipher.CAMELLIA_192 XMLCipher.CAMELLIA_256 The default value is MLCipher.TRIPLEDES</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="passPhrase" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">A String used as passPhrase to encrypt/decrypt content. The passPhrase has to be provided. If no passPhrase is specified a default passPhrase is used. The passPhrase needs to be put together in conjunction with the appropriate encryption algorithm. For example using TRIPLEDES the passPhase can be a Only another 24 Byte key</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="secureTag" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The XPath reference to the XML Element selected for encryption/decryption. If no tag is specified the entire payload is encrypted/decrypted.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="secureTagContents" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">A boolean value to specify whether the XML Element is to be encrypted or the contents of the XML Element false = Element Level true = Element Content Level</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="keyCipherAlgorithm" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The cipher algorithm to be used for encryption/decryption of the asymmetric key. The available choices are: XMLCipher.RSA_v1dot5 XMLCipher.RSA_OAEP XMLCipher.RSA_OAEP_11 The default value is XMLCipher.RSA_OAEP</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="recipientKeyAlias" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The key alias to be used when retrieving the recipient's public or private key from a KeyStore when performing asymmetric key encryption or decryption.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="keyOrTrustStoreParametersId" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Refers to a KeyStore instance to lookup in the registry which is used for configuration options for creating and loading a KeyStore instance that represents the sender's trustStore or recipient's keyStore.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="keyPassword" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The password to be used for retrieving the private key from the KeyStore. This key is used for asymmetric decryption.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="digestAlgorithm" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The digest algorithm to use with the RSA OAEP algorithm. The available choices are: XMLCipher.SHA1 XMLCipher.SHA256 XMLCipher.SHA512 The default value is XMLCipher.SHA1</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="mgfAlgorithm" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The MGF Algorithm to use with the RSA OAEP algorithm. The available choices are: EncryptionConstants.MGF1_SHA1 EncryptionConstants.MGF1_SHA256 EncryptionConstants.MGF1_SHA512 The default value is EncryptionConstants.MGF1_SHA1</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="addKeyValueForEncryptedKey" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to add the public key used to encrypt the session key as a KeyValue in the EncryptedKey structure or not.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="serializationDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="soapJaxbDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="contextPath" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">Package name where your JAXB classes are located.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="encoding" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To overrule and use a specific encoding</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="elementNameStrategyRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Refers to an element strategy to lookup from the registry. An element name strategy is used for two purposes. The first is to find a xml element name for a given object and soap action when marshaling the object into a SOAP message. The second is to find an Exception class for a given soap fault name. The following three element strategy class name is provided out of the box. QNameStrategy - Uses a fixed qName that is configured on instantiation. Exception lookup is not supported TypeNameStrategy - Uses the name and namespace from the XMLType annotation of the given type. If no namespace is set then package-info is used. Exception lookup is not supported ServiceInterfaceStrategy - Uses information from a webservice interface to determine the type name and to find the exception class for a SOAP fault All three classes is located in the package name org.apache.camel.dataformat.soap.name If you have generated the web service stub code with cxf-codegen or a similar tool then you probably will want to use the ServiceInterfaceStrategy. In the case you have no annotated service interface you should use QNameStrategy or TypeNameStrategy.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="version" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">SOAP version should either be 1.1 or 1.2. Is by default 1.1</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="namespacePrefixRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">When marshalling using JAXB or SOAP then the JAXB implementation will automatic assign namespace prefixes such as ns2 ns3 ns4 etc. To control this mapping Camel allows you to refer to a map which contains the desired mapping.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="schema" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To validate against an existing schema. Your can use the prefix classpath: file: or http: to specify how the resource should by resolved. You can separate multiple schema files by using the '' character.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="stringDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="charset" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets an encoding to use. Will by default use the JVM platform default charset.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="syslogDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="tidyMarkupDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="dataObjectType" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">What data type to unmarshal as can either be org.w3c.dom.Node or java.lang.String. Is by default org.w3c.dom.Node</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="uniVocityCsvDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:uniVocityAbstractDataFormat">
        <xs:sequence/>
        <xs:attribute name="quoteAllFields" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether or not all values must be quoted when writing them.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="quote" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The quote symbol.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="quoteEscape" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The quote escape symbol</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="delimiter" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The delimiter of values</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="uniVocityAbstractDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:univocity-header"/>
        </xs:sequence>
        <xs:attribute name="nullValue" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The string representation of a null value. The default value is null</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="skipEmptyLines" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether or not the empty lines must be ignored. The default value is true</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ignoreTrailingWhitespaces" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether or not the trailing white spaces must ignored. The default value is true</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ignoreLeadingWhitespaces" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether or not the leading white spaces must be ignored. The default value is true</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="headersDisabled" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether or not the headers are disabled. When defined this option explicitly sets the headers as null which indicates that there is no header. The default value is false</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="headerExtractionEnabled" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether or not the header must be read in the first line of the test document The default value is false</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="numberOfRecordsToRead" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en">The maximum number of record to read.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="emptyValue" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The String representation of an empty value</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="lineSeparator" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The line separator of the files The default value is to use the JVM platform line separator</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="normalizedLineSeparator" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The normalized line separator of the files The default value is \n</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="comment" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The comment symbol. The default value is</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="lazyLoad" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether the unmarshalling should produce an iterator that reads the lines on the fly or if all the lines must be read at one. The default value is false</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="asMap" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether the unmarshalling should produce maps for the lines values instead of lists. It requires to have header (either defined or collected). The default value is false</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="uniVocityHeader">
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="length" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en">Header length</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="uniVocityFixedWidthDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:uniVocityAbstractDataFormat">
        <xs:sequence/>
        <xs:attribute name="skipTrailingCharsUntilNewline" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether or not the trailing characters until new line must be ignored. The default value is false</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="recordEndsOnNewline" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether or not the record ends on new line. The default value is false</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="padding" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The padding character. The default value is a space</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="uniVocityTsvDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:uniVocityAbstractDataFormat">
        <xs:sequence/>
        <xs:attribute name="escapeChar" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The escape character.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="xmlBeansDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="prettyPrint" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">To enable pretty printing output nicely formatted. Is by default false.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="xmlJsonDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="encoding" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the encoding. Used for unmarshalling (JSON to XML conversion).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="elementName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Specifies the name of the XML elements representing each array element. Used for unmarshalling (JSON to XML conversion).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="arrayName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Specifies the name of the top-level XML element. Used for unmarshalling (JSON to XML conversion). For example when converting 1 2 3 it will be output by default as 123. By setting this option or rootName you can alter the name of element 'a'.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="forceTopLevelObject" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Determines whether the resulting JSON will start off with a top-most element whose name matches the XML root element. Used for marshalling (XML to JSon conversion). If disabled XML string 12 turns into 'x: '1' 'y': '2' . Otherwise it turns into 'a': 'x: '1' 'y': '2' .</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="namespaceLenient" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Flag to be tolerant to incomplete namespace prefixes. Used for unmarshalling (JSON to XML conversion). In most cases json-lib automatically changes this flag at runtime to match the processing.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="rootName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Specifies the name of the top-level element. Used for unmarshalling (JSON to XML conversion). If not set json-lib will use arrayName or objectName (default value: 'o' at the current time it is not configurable in this data format). If set to 'root' the JSON string 'x': 'value1' 'y' : 'value2' would turn into value1value2 otherwise the 'root' element would be named 'o'.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="skipWhitespace" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Determines whether white spaces between XML elements will be regarded as text values or disregarded. Used for marshalling (XML to JSon conversion).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="trimSpaces" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Determines whether leading and trailing white spaces will be omitted from String values. Used for marshalling (XML to JSon conversion).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="skipNamespaces" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Signals whether namespaces should be ignored. By default they will be added to the JSON output using xmlns elements. Used for marshalling (XML to JSon conversion).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="removeNamespacePrefixes" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Removes the namespace prefixes from XML qualified elements so that the resulting JSON string does not contain them. Used for marshalling (XML to JSon conversion).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="expandableProperties">
          <xs:annotation>
            <xs:documentation xml:lang="en">With expandable properties JSON array elements are converted to XML as a sequence of repetitive XML elements with the local name equal to the JSON key for example: number: 123 normally converted to: 123 (where e can be modified by setting elementName) would instead translate to 123 if number is set as an expandable property Used for unmarshalling (JSON to XML conversion).</xs:documentation>
          </xs:annotation>
          <xs:simpleType>
            <xs:list itemType="xs:string"/>
          </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="typeHints" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Adds type hints to the resulting XML to aid conversion back to JSON. Used for unmarshalling (JSON to XML conversion).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="xmlRpcDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="request" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to unmarshal request or response Is by default false</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="xStreamDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence>
          <xs:element minOccurs="0" name="converters" type="tns:converterList"/>
          <xs:element minOccurs="0" name="aliases" type="tns:aliasList"/>
          <xs:element minOccurs="0" name="omitFields" type="tns:omitFieldList"/>
          <xs:element minOccurs="0" name="implicitCollections" type="tns:implicitCollectionList"/>
        </xs:sequence>
        <xs:attribute name="encoding" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the encoding to use</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="driver" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To use a custom XStream driver. The instance must be of type com.thoughtworks.xstream.io.HierarchicalStreamDriver</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="driverRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To refer to a custom XStream driver to lookup in the registry. The instance must be of type com.thoughtworks.xstream.io.HierarchicalStreamDriver</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="mode" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Mode for dealing with duplicate references The possible values are: NO_REFERENCES ID_REFERENCES XPATH_RELATIVE_REFERENCES XPATH_ABSOLUTE_REFERENCES SINGLE_NODE_XPATH_RELATIVE_REFERENCES SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="converterList">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="converter" type="tns:converterEntry"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="converterEntry">
    <xs:sequence/>
    <xs:attribute name="class" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="aliasList">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="alias" type="tns:aliasEntry"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="aliasEntry">
    <xs:sequence/>
    <xs:attribute name="name" type="xs:string"/>
    <xs:attribute name="class" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="omitFieldList">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="omitField" type="tns:omitFieldEntry"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="omitFieldEntry">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="field" type="xs:string"/>
    </xs:sequence>
    <xs:attribute name="class" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="implicitCollectionList">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="class" type="tns:implicitCollectionEntry"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="implicitCollectionEntry">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="field" type="xs:string"/>
    </xs:sequence>
    <xs:attribute name="name" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="pgpDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="keyUserid" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The user ID of the key in the PGP keyring used during encryption. Can also be only a part of a user ID. For example if the user ID is Test User then you can use the part Test User or to address the user ID.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="signatureKeyUserid" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">User ID of the key in the PGP keyring used for signing (during encryption) or signature verification (during decryption). During the signature verification process the specified User ID restricts the public keys from the public keyring which can be used for the verification. If no User ID is specified for the signature verficiation then any public key in the public keyring can be used for the verification. Can also be only a part of a user ID. For example if the user ID is Test User then you can use the part Test User or to address the User ID.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="password" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Password used when opening the private key (not used for encryption).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="signaturePassword" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Password used when opening the private key used for signing (during encryption).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="keyFileName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Filename of the keyring; must be accessible as a classpath resource (but you can specify a location in the file system by using the file: prefix).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="signatureKeyFileName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Filename of the keyring to use for signing (during encryption) or for signature verification (during decryption); must be accessible as a classpath resource (but you can specify a location in the file system by using the file: prefix).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="signatureKeyRing" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Keyring used for signing/verifying as byte array. You can not set the signatureKeyFileName and signatureKeyRing at the same time.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="armored" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">This option will cause PGP to base64 encode the encrypted text making it available for copy/paste etc.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="integrity" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Adds an integrity check/sign into the encryption file. The default value is true.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="provider" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Java Cryptography Extension (JCE) provider default is Bouncy Castle (BC). Alternatively you can use for example the IAIK JCE provider; in this case the provider must be registered beforehand and the Bouncy Castle provider must not be registered beforehand. The Sun JCE provider does not work.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="algorithm" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en">Symmetric key encryption algorithm; possible values are defined in org.bouncycastle.bcpg.SymmetricKeyAlgorithmTags; for example 2 (= TRIPLE DES) 3 (= CAST5) 4 (= BLOWFISH) 6 (= DES) 7 (= AES_128). Only relevant for encrypting.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="compressionAlgorithm" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en">Compression algorithm; possible values are defined in org.bouncycastle.bcpg.CompressionAlgorithmTags; for example 0 (= UNCOMPRESSED) 1 (= ZIP) 2 (= ZLIB) 3 (= BZIP2). Only relevant for encrypting.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="hashAlgorithm" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en">Signature hash algorithm; possible values are defined in org.bouncycastle.bcpg.HashAlgorithmTags; for example 2 (= SHA1) 8 (= SHA256) 9 (= SHA384) 10 (= SHA512) 11 (=SHA224). Only relevant for signing.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="signatureVerificationOption" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Controls the behavior for verifying the signature during unmarshaling. There are 4 values possible: optional: The PGP message may or may not contain signatures; if it does contain signatures then a signature verification is executed. required: The PGP message must contain at least one signature; if this is not the case an exception (PGPException) is thrown. A signature verification is executed. ignore: Contained signatures in the PGP message are ignored; no signature verification is executed. no_signature_allowed: The PGP message must not contain a signature; otherwise an exception (PGPException) is thrown.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="zipDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="compressionLevel" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en">To specify a specific compression between 0-9. -1 is default compression 0 is no compression and 9 is best compression.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="zipFileDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="usingIterator" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">If the zip file has more then one entry the setting this option to true allows to work with the splitter EIP to split the data using an iterator in a streaming mode.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelRedeliveryPolicyFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelRedeliveryPolicyFactoryBean">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="abstractCamelRedeliveryPolicyFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelFactoryBean">
        <xs:sequence/>
        <xs:attribute name="maximumRedeliveries" type="xs:string"/>
        <xs:attribute name="redeliveryDelay" type="xs:string"/>
        <xs:attribute name="asyncDelayedRedelivery" type="xs:string"/>
        <xs:attribute name="backOffMultiplier" type="xs:string"/>
        <xs:attribute name="useExponentialBackOff" type="xs:string"/>
        <xs:attribute name="collisionAvoidanceFactor" type="xs:string"/>
        <xs:attribute name="useCollisionAvoidance" type="xs:string"/>
        <xs:attribute name="maximumRedeliveryDelay" type="xs:string"/>
        <xs:attribute name="retriesExhaustedLogLevel" type="tns:loggingLevel"/>
        <xs:attribute name="retryAttemptedLogLevel" type="tns:loggingLevel"/>
        <xs:attribute name="logRetryAttempted" type="xs:string"/>
        <xs:attribute name="logStackTrace" type="xs:string"/>
        <xs:attribute name="logRetryStackTrace" type="xs:string"/>
        <xs:attribute name="logHandled" type="xs:string"/>
        <xs:attribute name="logContinued" type="xs:string"/>
        <xs:attribute name="logExhausted" type="xs:string"/>
        <xs:attribute name="disableRedelivery" type="xs:string"/>
        <xs:attribute name="delayPattern" type="xs:string"/>
        <xs:attribute name="allowRedeliveryWhileStopping" type="xs:string"/>
        <xs:attribute name="exchangeFormatterRef" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="onExceptionDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" name="exception" type="xs:string"/>
          <xs:element minOccurs="0" name="onWhen" type="tns:whenDefinition"/>
          <xs:element minOccurs="0" name="retryWhile" type="tns:expressionSubElementDefinition"/>
          <xs:element minOccurs="0" ref="tns:redeliveryPolicy"/>
          <xs:element minOccurs="0" name="handled" type="tns:expressionSubElementDefinition"/>
          <xs:element minOccurs="0" name="continued" type="tns:expressionSubElementDefinition"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:aop"/>
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setFaultBody"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:restBinding"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="redeliveryPolicyRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets a reference to a RedeliveryPolicy to lookup in the org.apache.camel.spi.Registry to be used.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="onRedeliveryRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets a reference to a processor that should be processed before a redelivery attempt. Can be used to change the org.apache.camel.Exchange before its being redelivered.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="useOriginalMessage" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Will use the original input message when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN body we use the original IN body instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN body. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN body is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. By default this feature is off.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="processorDefinition">
    <xs:complexContent>
      <xs:extension base="tns:optionalIdentifiedDefinition">
        <xs:sequence/>
        <xs:attribute name="inheritErrorHandler" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets whether or not to inherit the configured error handler. The default value is true. You can use this to disable using the inherited error handler for a given DSL such as a load balancer where you want to use a custom error handler strategy.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="whenDefinition">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="expressionNode">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:choice>
            <xs:element ref="tns:expressionDefinition"/>
            <xs:element ref="tns:constant"/>
            <xs:element ref="tns:el"/>
            <xs:element ref="tns:exchangeProperty"/>
            <xs:element ref="tns:groovy"/>
            <xs:element ref="tns:header"/>
            <xs:element ref="tns:jxpath"/>
            <xs:element ref="tns:javaScript"/>
            <xs:element ref="tns:jsonpath"/>
            <xs:element ref="tns:language"/>
            <xs:element ref="tns:method"/>
            <xs:element ref="tns:mvel"/>
            <xs:element ref="tns:ognl"/>
            <xs:element ref="tns:php"/>
            <xs:element ref="tns:python"/>
            <xs:element ref="tns:ref"/>
            <xs:element ref="tns:ruby"/>
            <xs:element ref="tns:simple"/>
            <xs:element ref="tns:spel"/>
            <xs:element ref="tns:sql"/>
            <xs:element ref="tns:terser"/>
            <xs:element ref="tns:tokenize"/>
            <xs:element ref="tns:vtdxml"/>
            <xs:element ref="tns:xtokenize"/>
            <xs:element ref="tns:xpath"/>
            <xs:element ref="tns:xquery"/>
          </xs:choice>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:aop"/>
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setFaultBody"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:restBinding"/>
          </xs:choice>
        </xs:sequence>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="expression">
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="id" type="xs:ID">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the id of this node</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="trim" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to trim the value to remove leading and trailing whitespaces and line breaks</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="expressionSubElementDefinition">
    <xs:choice>
      <xs:element ref="tns:expressionDefinition"/>
      <xs:element ref="tns:constant"/>
      <xs:element ref="tns:el"/>
      <xs:element ref="tns:exchangeProperty"/>
      <xs:element ref="tns:groovy"/>
      <xs:element ref="tns:header"/>
      <xs:element ref="tns:jxpath"/>
      <xs:element ref="tns:javaScript"/>
      <xs:element ref="tns:jsonpath"/>
      <xs:element ref="tns:language"/>
      <xs:element ref="tns:method"/>
      <xs:element ref="tns:mvel"/>
      <xs:element ref="tns:ognl"/>
      <xs:element ref="tns:php"/>
      <xs:element ref="tns:python"/>
      <xs:element ref="tns:ref"/>
      <xs:element ref="tns:ruby"/>
      <xs:element ref="tns:simple"/>
      <xs:element ref="tns:spel"/>
      <xs:element ref="tns:sql"/>
      <xs:element ref="tns:terser"/>
      <xs:element ref="tns:tokenize"/>
      <xs:element ref="tns:vtdxml"/>
      <xs:element ref="tns:xtokenize"/>
      <xs:element ref="tns:xpath"/>
      <xs:element ref="tns:xquery"/>
    </xs:choice>
  </xs:complexType>

  <xs:complexType name="onCompletionDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:element minOccurs="0" name="onWhen" type="tns:whenDefinition"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:aop"/>
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setFaultBody"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:restBinding"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="mode" type="tns:onCompletionMode">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the on completion mode. The default value is AfterConsumer</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="onCompleteOnly" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Will only synchronize when the org.apache.camel.Exchange completed successfully (no errors).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="onFailureOnly" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Will only synchronize when the org.apache.camel.Exchange ended with failure (exception or FAULT message).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="parallelProcessing" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">If enabled then the on completion process will run asynchronously by a separate thread from a thread pool. By default this is false meaning the on completion process will run synchronously using the same caller thread as from the route.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="executorServiceRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Refers to a custom Thread Pool to be used for parallel processing. Notice if you set this option then parallel processing is automatic implied and you do not have to enable that option as well.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="useOriginalMessage" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Will use the original input body when an org.apache.camel.Exchange for this on completion. By default this feature is off.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="interceptDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="output">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:aop"/>
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setFaultBody"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:restBinding"/>
          </xs:choice>
        </xs:sequence>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="interceptFromDefinition">
    <xs:complexContent>
      <xs:extension base="tns:interceptDefinition">
        <xs:sequence/>
        <xs:attribute name="uri" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Intercept incoming messages from the uri or uri pattern. If this option is not configured then all incoming messages is intercepted.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="interceptSendToEndpointDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:attribute name="uri" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">Intercept sending to the uri or uri pattern.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="skipSendToOriginalEndpoint" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">If set to true then the message is not sent to the original endpoint. By default (false) the message is both intercepted and then sent to the original endpoint.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="restConfigurationDefinition">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="componentProperty" type="tns:restPropertyDefinition"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="endpointProperty" type="tns:restPropertyDefinition"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="consumerProperty" type="tns:restPropertyDefinition"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="dataFormatProperty" type="tns:restPropertyDefinition"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="corsHeaders" type="tns:restPropertyDefinition"/>
    </xs:sequence>
    <xs:attribute name="component" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">The Camel Rest component to use for the REST transport such as restlet spark-rest. If no component has been explicit configured then Camel will lookup if there is a Camel component that integrates with the Rest DSL or if a org.apache.camel.spi.RestConsumerFactory is registered in the registry. If either one is found then that is being used.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scheme" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">The scheme to use for exposing the REST service. Usually http or https is supported. The default value is http</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="host" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">The hostname to use for exposing the REST service.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">The port number to use for exposing the REST service. Notice if you use servlet component then the port number configured here does not apply as the port number in use is the actual port number the servlet component is using. eg if using Apache Tomcat its the tomcat http port if using Apache Karaf its the HTTP service in Karaf that uses port 8181 by default etc. Though in those situations setting the port number here allows tooling and JMX to know the port number so its recommended to set the port number to the number that the servlet engine uses.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="contextPath" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Sets a leading context-path the REST services will be using. This can be used when using components such as SERVLET where the deployed web application is deployed using a context-path.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hostNameResolver" type="tns:restHostNameResolver">
      <xs:annotation>
        <xs:documentation xml:lang="en">If no hostname has been explicit configured then this resolver is used to compute the hostname the REST service will be using.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="bindingMode" type="tns:restBindingMode">
      <xs:annotation>
        <xs:documentation xml:lang="en">Sets the binding mode to use. The default value is auto</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipBindingOnErrorCode" type="xs:boolean">
      <xs:annotation>
        <xs:documentation xml:lang="en">Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc as success messages otherwise will do.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="enableCORS" type="xs:boolean">
      <xs:annotation>
        <xs:documentation xml:lang="en">Whether to enable CORS headers in the HTTP response. The default value is false.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsonDataFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Name of specific json data format to use. By default json-jackson will be used. Important: This option is only for setting a custom name of the data format not to refer to an existing data format instance.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlDataFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation xml:lang="en">Name of specific XML data format to use. By default jaxb will be used. Important: This option is only for setting a custom name of the data format not to refer to an existing data format instance.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="restPropertyDefinition">
    <xs:sequence/>
    <xs:attribute name="key" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Property key</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en">Property value</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="restDefinition">
    <xs:complexContent>
      <xs:extension base="tns:optionalIdentifiedDefinition">
        <xs:sequence>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:verb"/>
            <xs:element ref="tns:delete"/>
            <xs:element ref="tns:get"/>
            <xs:element ref="tns:head"/>
            <xs:element ref="tns:post"/>
            <xs:element ref="tns:put"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="path" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Path of the rest service such as /foo</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="consumes" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To define the content type what the REST service consumes (accept as input) such as application/xml or application/json. This option will override what may be configured on a parent level</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="produces" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To define the content type what the REST service produces (uses for output) such as application/xml or application/json This option will override what may be configured on a parent level</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="bindingMode" type="tns:restBindingMode">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the binding mode to use. This option will override what may be configured on a parent level The default value is auto</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="skipBindingOnErrorCode" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc as success messages otherwise will do. This option will override what may be configured on a parent level</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="enableCORS" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to enable CORS headers in the HTTP response. This option will override what may be configured on a parent level The default value is false.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="verbDefinition">
    <xs:complexContent>
      <xs:extension base="tns:optionalIdentifiedDefinition">
        <xs:sequence>
          <xs:choice minOccurs="0">
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:route"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="method" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The HTTP verb such as GET or POST</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="uri" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Uri template of this REST service such as /id.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="consumes" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To define the content type what the REST service consumes (accept as input) such as application/xml or application/json. This option will override what may be configured on a parent level</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="produces" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To define the content type what the REST service produces (uses for output) such as application/xml or application/json This option will override what may be configured on a parent level</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="bindingMode" type="tns:restBindingMode">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the binding mode to use. This option will override what may be configured on a parent level The default value is auto</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="skipBindingOnErrorCode" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc as success messages otherwise will do. This option will override what may be configured on a parent level</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="enableCORS" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to enable CORS headers in the HTTP response. This option will override what may be configured on a parent level The default value is false.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="type" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the class name to use for binding from input to POJO for the incoming data This option will override what may be configured on a parent level</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="outType" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the class name to use for binding from POJO to output for the outgoing data This option will override what may be configured on a parent level</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="toDefinition">
    <xs:complexContent>
      <xs:extension base="tns:sendDefinition">
        <xs:sequence/>
        <xs:attribute name="pattern" type="tns:exchangePattern">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the optional ExchangePattern used to invoke this endpoint</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="sendDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="uri" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the uri of the endpoint to send to.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ref" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the reference of the endpoint to send to.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="noOutputDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence/>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="routeDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:from"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:aop"/>
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setFaultBody"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:restBinding"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="autoStartup" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to auto start this route</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="delayer" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to slow down processing messages by a given delay in msec.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="errorHandlerRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the bean ref name of the error handler builder to use on this route</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="group" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The group that this route belongs to; could be the name of the RouteBuilder class or be explicitly configured in the XML. May be null.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="handleFault" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether handle fault is enabled on this route.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="messageHistory" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether message history is enabled on this route.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="rest" type="xs:boolean"/>
        <xs:attribute name="routePolicyRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Reference to custom org.apache.camel.spi.RoutePolicy to use by the route. Multiple policies can be configured by separating values using comma.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="shutdownRoute" type="tns:shutdownRoute">
          <xs:annotation>
            <xs:documentation xml:lang="en">To control how to shutdown the route.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="shutdownRunningTask" type="tns:shutdownRunningTask">
          <xs:annotation>
            <xs:documentation xml:lang="en">To control how to shutdown the route.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="startupOrder" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en">To configure the ordering of the routes being started</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="streamCache" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether stream caching is enabled on this route.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="trace" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether tracing is enabled on this route.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="fromDefinition">
    <xs:complexContent>
      <xs:extension base="tns:optionalIdentifiedDefinition">
        <xs:sequence/>
        <xs:attribute name="uri" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the URI of the endpoint to use</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ref" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the name of the endpoint within the registry (such as the Spring ApplicationContext or JNDI) to use</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelRestContextFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" ref="tns:rest"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelRouteContextFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" ref="tns:route"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelProxyFactoryDefinition">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="serviceUrl" type="xs:string"/>
        <xs:attribute name="serviceRef" type="xs:string"/>
        <xs:attribute name="serviceInterface" type="xs:string"/>
        <xs:attribute name="camelContextId" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="patternBasedPackageScanFilter">
    <xs:sequence/>
  </xs:complexType>

  <xs:complexType abstract="true" name="abstractJsseUtilFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelFactoryBean">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="abstractKeyManagersParametersFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractJsseUtilFactoryBean">
        <xs:sequence/>
        <xs:attribute name="keyPassword" type="xs:string"/>
        <xs:attribute name="provider" type="xs:string"/>
        <xs:attribute name="algorithm" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="abstractKeyStoreParametersFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractJsseUtilFactoryBean">
        <xs:sequence/>
        <xs:attribute name="type" type="xs:string"/>
        <xs:attribute name="password" type="xs:string"/>
        <xs:attribute name="provider" type="xs:string"/>
        <xs:attribute name="resource" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="abstractSecureRandomParametersFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractJsseUtilFactoryBean">
        <xs:sequence/>
        <xs:attribute name="algorithm" type="xs:string" use="required"/>
        <xs:attribute name="provider" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="abstractTrustManagersParametersFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractJsseUtilFactoryBean">
        <xs:sequence/>
        <xs:attribute name="provider" type="xs:string"/>
        <xs:attribute name="algorithm" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="cipherSuitesParameters">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="cipherSuite" nillable="true" type="xs:string"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="filterParameters">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="include" nillable="true" type="xs:string"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="exclude" nillable="true" type="xs:string"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="secureSocketProtocolsParameters">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="secureSocketProtocol" nillable="true" type="xs:string"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="aopDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:attribute name="beforeUri" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Endpoint to call in AOP before.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="afterUri" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Endpoint to call in AOP after. The difference between after and afterFinally is that afterFinally is invoked from a finally block so it will always be invoked no matter what eg also in case of an exception occur.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="afterFinallyUri" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Endpoint to call in AOP after finally. The difference between after and afterFinally is that afterFinally is invoked from a finally block so it will always be invoked no matter what eg also in case of an exception occur.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="aggregateDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:element name="correlationExpression" type="tns:expressionSubElementDefinition"/>
          <xs:element minOccurs="0" name="completionPredicate" type="tns:expressionSubElementDefinition"/>
          <xs:element minOccurs="0" name="completionTimeout" type="tns:expressionSubElementDefinition"/>
          <xs:element minOccurs="0" name="completionSize" type="tns:expressionSubElementDefinition"/>
          <xs:element minOccurs="0" ref="tns:optimisticLockRetryPolicy"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:aop"/>
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setFaultBody"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:restBinding"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="parallelProcessing" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">When aggregated are completed they are being send out of the aggregator. This option indicates whether or not Camel should use a thread pool with multiple threads for concurrency. If no custom thread pool has been specified then Camel creates a default pool with 10 concurrent threads.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="optimisticLocking" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Turns on using optimistic locking which requires the aggregationRepository being used is supporting this by implementing org.apache.camel.spi.OptimisticLockingAggregationRepository.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="executorServiceRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">If using parallelProcessing you can specify a custom thread pool to be used. In fact also if you are not using parallelProcessing this custom thread pool is used to send out aggregated exchanges as well.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="timeoutCheckerExecutorServiceRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">If using either of the completionTimeout completionTimeoutExpression or completionInterval options a background thread is created to check for the completion for every aggregator. Set this option to provide a custom thread pool to be used rather than creating a new thread for every aggregator.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="aggregationRepositoryRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the custom aggregate repository to use Will by default use org.apache.camel.processor.aggregate.MemoryAggregationRepository</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="strategyRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">A reference to lookup the AggregationStrategy in the Registry. Configuring an AggregationStrategy is required and is used to merge the incoming Exchange with the existing already merged exchanges. At first call the oldExchange parameter is null. On subsequent invocations the oldExchange contains the merged exchanges and newExchange is of course the new incoming Exchange.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="strategyMethodName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">This option can be used to explicit declare the method name to use when using POJOs as the AggregationStrategy.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="strategyMethodAllowNull" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">If this option is false then the aggregate method is not used for the very first aggregation. If this option is true then null values is used as the oldExchange (at the very first aggregation) when using POJOs as the AggregationStrategy.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="completionSize" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the completion size which is the number of aggregated exchanges which would cause the aggregate to consider the group as complete and send out the aggregated exchange.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="completionInterval" type="xs:long">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the completion interval which would cause the aggregate to consider the group as complete and send out the aggregated exchange.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="completionTimeout" type="xs:long">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the completion timeout which would cause the aggregate to consider the group as complete and send out the aggregated exchange.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="completionFromBatchConsumer" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Enables the batch completion mode where we aggregate from a org.apache.camel.BatchConsumer and aggregate the total number of exchanges the org.apache.camel.BatchConsumer has reported as total by checking the exchange property link org.apache.camel.ExchangeBATCH_COMPLETE when its complete.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="groupExchanges" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Enables grouped exchanges so the aggregator will group all aggregated exchanges into a single combined Exchange holding all the aggregated exchanges in a java.util.List.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="eagerCheckCompletion" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Use eager completion checking which means that the completionPredicate will use the incoming Exchange. At opposed to without eager completion checking the completionPredicate will use the aggregated Exchange.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ignoreInvalidCorrelationKeys" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">If a correlation key cannot be successfully evaluated it will be ignored by logging a DEBUG and then just ignore the incoming Exchange.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="closeCorrelationKeyOnCompletion" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en">Closes a correlation key when its complete. Any late received exchanges which has a correlation key that has been closed it will be defined and a org.apache.camel.processor.aggregate.ClosedCorrelationKeyException is thrown.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="discardOnCompletionTimeout" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Discards the aggregated message on completion timeout. This means on timeout the aggregated message is dropped and not sent out of the aggregator.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="forceCompletionOnStop" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Indicates to complete all current aggregated exchanges when the context is stopped</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="optimisticLockRetryPolicyDefinition">
    <xs:sequence/>
    <xs:attribute name="maximumRetries" type="xs:int">
      <xs:annotation>
        <xs:documentation xml:lang="en">Sets the maximum number of retries</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryDelay" type="xs:long">
      <xs:annotation>
        <xs:documentation xml:lang="en">Sets the delay in millis between retries</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maximumRetryDelay" type="xs:long">
      <xs:annotation>
        <xs:documentation xml:lang="en">Sets the upper value of retry in millis between retries when using exponential or random backoff</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exponentialBackOff" type="xs:boolean">
      <xs:annotation>
        <xs:documentation xml:lang="en">Enable exponential backoff</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="randomBackOff" type="xs:boolean">
      <xs:annotation>
        <xs:documentation xml:lang="en">Enables random backoff</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="beanDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets a reference to a bean to use</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="method" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the method name on the bean to use</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="beanType" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the Class of the bean</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="cache" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Caches the bean lookup to avoid lookup up bean on every usage.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="multiParameterArray" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether the message body is an array type.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="catchDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="exception" type="xs:string"/>
          <xs:element minOccurs="0" name="onWhen" type="tns:whenDefinition"/>
          <xs:element minOccurs="0" name="handled" type="tns:expressionSubElementDefinition"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:aop"/>
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setFaultBody"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:restBinding"/>
          </xs:choice>
        </xs:sequence>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="choiceDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
          </xs:choice>
          <xs:element minOccurs="0" ref="tns:otherwise"/>
        </xs:sequence>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="otherwiseDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType final="extension restriction" name="constants">
    <xs:sequence/>
  </xs:complexType>

  <xs:complexType name="convertBodyDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="type" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">The java type to convert to</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="charset" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To use a specific charset when converting</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="delayDefinition">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
        <xs:attribute name="executorServiceRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Refers to a custom Thread Pool if asyncDelay has been enabled.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="asyncDelayed" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Enables asynchronous delay which means the thread will noy block while delaying.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="callerRunsWhenRejected" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether or not the caller should run the task when it was rejected by the thread pool. Is by default true</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="dynamicRouterDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputExpressionNode">
        <xs:sequence/>
        <xs:attribute name="uriDelimiter" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the uri delimiter to use</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ignoreInvalidEndpoints" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Ignore the invalidate endpoint exception when try to create a producer with that endpoint</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="noOutputExpressionNode">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="enrichDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="uri" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The endpoint uri for the external service to enrich from. You must use either uri or ref.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ref" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Refers to the endpoint for the external service to enrich from. You must use either uri or ref.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="strategyRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Refers to an AggregationStrategy to be used to merge the reply from the external service into a single outgoing message. By default Camel will use the reply from the external service as outgoing message.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="strategyMethodName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">This option can be used to explicit declare the method name to use when using POJOs as the AggregationStrategy.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="strategyMethodAllowNull" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">If this option is false then the aggregate method is not used if there was no data to enrich. If this option is true then null values is used as the oldExchange (when no data to enrich) when using POJOs as the AggregationStrategy.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="aggregateOnException" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">If this option is false then the aggregate method is not used if there was an exception thrown while trying to retrieve the data to enrich from the resource. Setting this option to true allows end users to control what to do if there was an exception in the aggregate method. For example to suppress the exception or set a custom message body etc.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType final="extension restriction" name="expressionNodeHelper">
    <xs:sequence/>
  </xs:complexType>

  <xs:complexType name="filterDefinition">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="finallyDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="idempotentConsumerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
        <xs:attribute name="messageIdRepositoryRef" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the reference name of the message id repository</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="eager" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets whether to eagerly add the key to the idempotent repository or wait until the exchange is complete. Eager is default enabled.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="skipDuplicate" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets whether to skip duplicates or not. The default behavior is to skip duplicates. A duplicate message would have the Exchange property link org.apache.camel.ExchangeDUPLICATE_MESSAGE set to a link BooleanTRUE value. A none duplicate message will not have this property set.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="removeOnFailure" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets whether to remove or keep the key on failure. The default behavior is to remove the key on failure.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="inOnlyDefinition">
    <xs:complexContent>
      <xs:extension base="tns:sendDefinition">
        <xs:sequence/>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="inOutDefinition">
    <xs:complexContent>
      <xs:extension base="tns:sendDefinition">
        <xs:sequence/>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="loadBalanceDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:choice minOccurs="0">
            <xs:element ref="tns:failover"/>
            <xs:element ref="tns:random"/>
            <xs:element name="custom" type="tns:customLoadBalancerDefinition"/>
            <xs:element ref="tns:roundRobin"/>
            <xs:element ref="tns:sticky"/>
            <xs:element ref="tns:topic"/>
            <xs:element ref="tns:weighted"/>
            <xs:element ref="tns:circuitBreaker"/>
          </xs:choice>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:aop"/>
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setFaultBody"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:restBinding"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="ref" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To use a custom load balancer. This option is deprecated use the custom load balancer type instead.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="failoverLoadBalancerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:loadBalancer">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="exception" type="xs:string"/>
        </xs:sequence>
        <xs:attribute name="roundRobin" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether or not the failover load balancer should operate in round robin mode or not. If not then it will always start from the first endpoint when a new message is to be processed. In other words it restart from the top for every message. If round robin is enabled then it keeps state and will continue with the next endpoint in a round robin fashion. When using round robin it will not stick to last known good endpoint it will always pick the next endpoint to use.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="maximumFailoverAttempts" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en">A value to indicate after X failover attempts we should exhaust (give up). Use -1 to indicate never give up and continuously try to failover. Use 0 to never failover. And use e.g. 3 to failover at most 3 times before giving up. his option can be used whether or not roundRobin is enabled or not.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="loadBalancer">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="randomLoadBalancerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:loadBalancer">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="customLoadBalancerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:loadBalancer">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">Refers to the custom load balancer to lookup from the registry</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="roundRobinLoadBalancerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:loadBalancer">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="stickyLoadBalancerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:loadBalancer">
        <xs:sequence>
          <xs:element name="correlationExpression" type="tns:expressionSubElementDefinition"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="topicLoadBalancerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:loadBalancer">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="weightedLoadBalancerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:loadBalancer">
        <xs:sequence/>
        <xs:attribute name="roundRobin" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">To enable round robin mode. By default the weighted distribution mode is used. The default value is false.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="distributionRatio" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">The distribution ratio is a delimited String consisting on integer weights separated by delimiters for example 235. The distributionRatio must match the number of endpoints and/or processors specified in the load balancer list.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="distributionRatioDelimiter" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Delimiter used to specify the distribution ratio. The default value is</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="circuitBreakerLoadBalancerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:loadBalancer">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="exception" type="xs:string"/>
        </xs:sequence>
        <xs:attribute name="halfOpenAfter" type="xs:long">
          <xs:annotation>
            <xs:documentation xml:lang="en">The timeout in millis to use as threshold to move state from closed to half-open or open state</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="threshold" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en">Number of previous failed messages to use as threshold to move state from closed to half-open or open state</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="logDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="message" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the log message (uses simple language)</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="loggingLevel" type="tns:loggingLevel">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the logging level. The default value is INFO</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="logName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the name of the logger</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="marker" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To use slf4j marker</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="loggerRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To refer to a custom logger instance to lookup from the registry.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="loopDefinition">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
        <xs:attribute name="copy" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">If the copy attribute is true a copy of the input Exchange is used for each iteration. That means each iteration will start from a copy of the same message. By default loop will loop the same exchange all over so each iteration may have different message content.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="marshalDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence>
          <xs:choice minOccurs="0">
            <xs:element ref="tns:avro"/>
            <xs:element ref="tns:base64"/>
            <xs:element ref="tns:beanio"/>
            <xs:element ref="tns:bindy"/>
            <xs:element ref="tns:castor"/>
            <xs:element ref="tns:crypto"/>
            <xs:element ref="tns:csv"/>
            <xs:element name="custom" type="tns:customDataFormat"/>
            <xs:element ref="tns:flatpack"/>
            <xs:element ref="tns:gzip"/>
            <xs:element ref="tns:hl7"/>
            <xs:element ref="tns:ical"/>
            <xs:element ref="tns:jaxb"/>
            <xs:element ref="tns:jibx"/>
            <xs:element ref="tns:json"/>
            <xs:element ref="tns:protobuf"/>
            <xs:element ref="tns:rss"/>
            <xs:element ref="tns:secureXML"/>
            <xs:element ref="tns:serialization"/>
            <xs:element ref="tns:soapjaxb"/>
            <xs:element ref="tns:string"/>
            <xs:element ref="tns:syslog"/>
            <xs:element ref="tns:tidyMarkup"/>
            <xs:element ref="tns:univocity-csv"/>
            <xs:element ref="tns:univocity-fixed"/>
            <xs:element ref="tns:univocity-tsv"/>
            <xs:element ref="tns:xmlBeans"/>
            <xs:element ref="tns:xmljson"/>
            <xs:element ref="tns:xmlrpc"/>
            <xs:element ref="tns:xstream"/>
            <xs:element ref="tns:pgp"/>
            <xs:element ref="tns:zip"/>
            <xs:element ref="tns:zipFile"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="ref" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To refer to a custom data format to use as marshaller</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType final="extension restriction" name="modelHelper">
    <xs:sequence/>
  </xs:complexType>

  <xs:complexType name="multicastDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:attribute name="parallelProcessing" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">If enabled then sending messages to the multicasts occurs concurrently. Note the caller thread will still wait until all messages has been fully processed before it continues. Its only the sending and processing the replies from the multicasts which happens concurrently.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="strategyRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Refers to an AggregationStrategy to be used to assemble the replies from the multicasts into a single outgoing message from the Multicast. By default Camel will use the last reply as the outgoing message. You can also use a POJO as the AggregationStrategy</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="strategyMethodName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">This option can be used to explicit declare the method name to use when using POJOs as the AggregationStrategy.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="strategyMethodAllowNull" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">If this option is false then the aggregate method is not used if there was no data to enrich. If this option is true then null values is used as the oldExchange (when no data to enrich) when using POJOs as the AggregationStrategy</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="executorServiceRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Refers to a custom Thread Pool to be used for parallel processing. Notice if you set this option then parallel processing is automatic implied and you do not have to enable that option as well.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="streaming" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">If enabled then Camel will process replies out-of-order eg in the order they come back. If disabled Camel will process replies in the same order as defined by the multicast.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="stopOnException" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Will now stop further processing if an exception or failure occurred during processing of an org.apache.camel.Exchange and the caused exception will be thrown. Will also stop if processing the exchange failed (has a fault message) or an exception was thrown and handled by the error handler (such as using onException). In all situations the multicast will stop further processing. This is the same behavior as in pipeline which is used by the routing engine. The default behavior is to not stop but continue processing till the end</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="timeout" type="xs:long">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets a total timeout specified in millis when using parallel processing. If the Multicast hasn't been able to send and process all replies within the given timeframe then the timeout triggers and the Multicast breaks out and continues. Notice if you provide a TimeoutAwareAggregationStrategy then the timeout method is invoked before breaking out. If the timeout is reached with running tasks still remaining certain tasks for which it is difficult for Camel to shut down in a graceful manner may continue to run. So use this option with a bit of care.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="onPrepareRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Uses the Processor when preparing the org.apache.camel.Exchange to be send. This can be used to deep-clone messages that should be send or any custom logic needed before the exchange is send.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="shareUnitOfWork" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Shares the org.apache.camel.spi.UnitOfWork with the parent and each of the sub messages. Multicast will by default not share unit of work between the parent exchange and each multicasted exchange. This means each sub exchange has its own individual unit of work.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="parallelAggregate" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">If enabled then the aggregate method on AggregationStrategy can be called concurrently. Notice that this would require the implementation of AggregationStrategy to be implemented as thread-safe. By default this is false meaning that Camel synchronizes the call to the aggregate method. Though in some use-cases this can be used to archive higher performance when the AggregationStrategy is implemented as thread-safe.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="pipelineDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="policyDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets a reference to use for lookup the policy in the registry.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="pollEnrichDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="uri" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The endpoint uri for the external service to poll enrich from. You must use either uri or ref.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ref" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Refers to the endpoint for the external service to poll enrich from. You must use either uri or ref.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="timeout" type="xs:long">
          <xs:annotation>
            <xs:documentation xml:lang="en">Timeout in millis when polling from the external service. The timeout has influence about the poll enrich behavior. It basically operations in three different modes: negative value - Waits until a message is available and then returns it. Warning that this method could block indefinitely if no messages are available. 0 - Attempts to receive a message exchange immediately without waiting and returning null if a message exchange is not available yet. positive value - Attempts to receive a message exchange waiting up to the given timeout to expire if a message is not yet available. Returns null if timed out The default value is -1 and therefore the method could block indefinitely and therefore its recommended to use a timeout value</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="strategyRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Refers to an AggregationStrategy to be used to merge the reply from the external service into a single outgoing message. By default Camel will use the reply from the external service as outgoing message.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="strategyMethodName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">This option can be used to explicit declare the method name to use when using POJOs as the AggregationStrategy.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="strategyMethodAllowNull" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">If this option is false then the aggregate method is not used if there was no data to enrich. If this option is true then null values is used as the oldExchange (when no data to enrich) when using POJOs as the AggregationStrategy.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="aggregateOnException" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">If this option is false then the aggregate method is not used if there was an exception thrown while trying to retrieve the data to enrich from the resource. Setting this option to true allows end users to control what to do if there was an exception in the aggregate method. For example to suppress the exception or set a custom message body etc.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="processDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">Reference to the Processor to lookup in the registry to use.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType final="extension restriction" name="processorDefinitionHelper">
    <xs:sequence/>
  </xs:complexType>

  <xs:complexType name="recipientListDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputExpressionNode">
        <xs:sequence/>
        <xs:attribute name="delimiter" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Delimiter used if the Expression returned multiple endpoints. Can be turned off using the value false. The default value is</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="parallelProcessing" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">If enabled then sending messages to the recipients occurs concurrently. Note the caller thread will still wait until all messages has been fully processed before it continues. Its only the sending and processing the replies from the recipients which happens concurrently.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="strategyRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets a reference to the AggregationStrategy to be used to assemble the replies from the recipients into a single outgoing message from the RecipientList. By default Camel will use the last reply as the outgoing message. You can also use a POJO as the AggregationStrategy</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="strategyMethodName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">This option can be used to explicit declare the method name to use when using POJOs as the AggregationStrategy.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="strategyMethodAllowNull" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">If this option is false then the aggregate method is not used if there was no data to enrich. If this option is true then null values is used as the oldExchange (when no data to enrich) when using POJOs as the AggregationStrategy</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="executorServiceRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Refers to a custom Thread Pool to be used for parallel processing. Notice if you set this option then parallel processing is automatic implied and you do not have to enable that option as well.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="stopOnException" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Will now stop further processing if an exception or failure occurred during processing of an org.apache.camel.Exchange and the caused exception will be thrown. Will also stop if processing the exchange failed (has a fault message) or an exception was thrown and handled by the error handler (such as using onException). In all situations the recipient list will stop further processing. This is the same behavior as in pipeline which is used by the routing engine. The default behavior is to not stop but continue processing till the end</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ignoreInvalidEndpoints" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Ignore the invalidate endpoint exception when try to create a producer with that endpoint</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="streaming" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">If enabled then Camel will process replies out-of-order eg in the order they come back. If disabled Camel will process replies in the same order as defined by the recipient list.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="timeout" type="xs:long">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets a total timeout specified in millis when using parallel processing. If the Recipient List hasn't been able to send and process all replies within the given timeframe then the timeout triggers and the Recipient List breaks out and continues. Notice if you provide a TimeoutAwareAggregationStrategy then the timeout method is invoked before breaking out. If the timeout is reached with running tasks still remaining certain tasks for which it is difficult for Camel to shut down in a graceful manner may continue to run. So use this option with a bit of care.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="onPrepareRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Uses the Processor when preparing the org.apache.camel.Exchange to be send. This can be used to deep-clone messages that should be send or any custom logic needed before the exchange is send.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="shareUnitOfWork" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Shares the org.apache.camel.spi.UnitOfWork with the parent and each of the sub messages. Recipient List will by default not share unit of work between the parent exchange and each recipient exchange. This means each sub exchange has its own individual unit of work.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="cacheSize" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the maximum size used by the org.apache.camel.impl.ProducerCache which is used to cache and reuse producers when using this recipient list when uris are reused.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="parallelAggregate" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">If enabled then the aggregate method on AggregationStrategy can be called concurrently. Notice that this would require the implementation of AggregationStrategy to be implemented as thread-safe. By default this is false meaning that Camel synchronizes the call to the aggregate method. Though in some use-cases this can be used to archive higher performance when the AggregationStrategy is implemented as thread-safe.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="removeHeaderDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="headerName" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">Name of header to remove</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="removeHeadersDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="pattern" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">Name or pattern of headers to remove</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="excludePattern" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Name or patter of headers to not remove</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="removePropertiesDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="pattern" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">Name or pattern of properties to remove</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="excludePattern" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Name or pattern of properties to not remove</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="removePropertyDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="propertyName" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">Name of property to remove</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="resequenceDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:choice minOccurs="0">
            <xs:element ref="tns:batch-config"/>
            <xs:element ref="tns:stream-config"/>
          </xs:choice>
          <xs:choice>
            <xs:element ref="tns:expressionDefinition"/>
            <xs:element ref="tns:constant"/>
            <xs:element ref="tns:el"/>
            <xs:element ref="tns:exchangeProperty"/>
            <xs:element ref="tns:groovy"/>
            <xs:element ref="tns:header"/>
            <xs:element ref="tns:jxpath"/>
            <xs:element ref="tns:javaScript"/>
            <xs:element ref="tns:jsonpath"/>
            <xs:element ref="tns:language"/>
            <xs:element ref="tns:method"/>
            <xs:element ref="tns:mvel"/>
            <xs:element ref="tns:ognl"/>
            <xs:element ref="tns:php"/>
            <xs:element ref="tns:python"/>
            <xs:element ref="tns:ref"/>
            <xs:element ref="tns:ruby"/>
            <xs:element ref="tns:simple"/>
            <xs:element ref="tns:spel"/>
            <xs:element ref="tns:sql"/>
            <xs:element ref="tns:terser"/>
            <xs:element ref="tns:tokenize"/>
            <xs:element ref="tns:vtdxml"/>
            <xs:element ref="tns:xtokenize"/>
            <xs:element ref="tns:xpath"/>
            <xs:element ref="tns:xquery"/>
          </xs:choice>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:aop"/>
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setFaultBody"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:restBinding"/>
          </xs:choice>
        </xs:sequence>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="batchResequencerConfig">
    <xs:complexContent>
      <xs:extension base="tns:resequencerConfig">
        <xs:sequence/>
        <xs:attribute name="batchSize" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the size of the batch to be re-ordered. The default size is 100.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="batchTimeout" type="xs:long">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the timeout for collecting elements to be re-ordered. The default timeout is 1000 msec.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="allowDuplicates" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to allow duplicates.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="reverse" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to reverse the ordering.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ignoreInvalidExchanges" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to ignore invalid exchanges</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="resequencerConfig">
    <xs:sequence/>
  </xs:complexType>

  <xs:complexType name="streamResequencerConfig">
    <xs:complexContent>
      <xs:extension base="tns:resequencerConfig">
        <xs:sequence/>
        <xs:attribute name="capacity" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the capacity of the resequencer's inbound queue.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="timeout" type="xs:long">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets minimum time to wait for missing elements (messages).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ignoreInvalidExchanges" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to ignore invalid exchanges</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="comparatorRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To use a custom comparator</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="rejectOld" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">If true throws an exception when messages older than the last delivered message are processed</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType final="extension restriction" name="restContextRefDefinitionHelper">
    <xs:sequence/>
  </xs:complexType>

  <xs:complexType name="rollbackDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="markRollbackOnly" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Mark the transaction for rollback only (cannot be overruled to commit)</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="markRollbackOnlyLast" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Mark only last sub transaction for rollback only. When using sub transactions (if the transaction manager support this)</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="message" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Message to use in rollback exception</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType final="extension restriction" name="routeContextRefDefinitionHelper">
    <xs:sequence/>
  </xs:complexType>

  <xs:complexType final="extension restriction" name="routeDefinitionHelper">
    <xs:sequence/>
  </xs:complexType>

  <xs:complexType name="routesDefinition">
    <xs:complexContent>
      <xs:extension base="tns:optionalIdentifiedDefinition">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:route"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="routingSlipDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputExpressionNode">
        <xs:sequence/>
        <xs:attribute name="uriDelimiter" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the uri delimiter to use</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ignoreInvalidEndpoints" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Ignore the invalidate endpoint exception when try to create a producer with that endpoint</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="cacheSize" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the maximum size used by the org.apache.camel.impl.ProducerCache which is used to cache and reuse producers when using this recipient list when uris are reused.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="samplingDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:attribute name="samplePeriod" type="xs:long">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the sample period during which only a single Exchange will pass through.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="messageFrequency" type="xs:long">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the sample message count which only a single Exchange will pass through after this many received.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="units" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the time units for the sample period defaulting to seconds.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="setBodyDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputExpressionNode">
        <xs:sequence/>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="setExchangePatternDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="pattern" type="tns:exchangePattern" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the new exchange pattern of the Exchange to be used from this point forward</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="setFaultBodyDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputExpressionNode">
        <xs:sequence/>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="setHeaderDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputExpressionNode">
        <xs:sequence/>
        <xs:attribute name="headerName" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">Name of message header to set a new value</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="setOutHeaderDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputExpressionNode">
        <xs:sequence/>
        <xs:attribute name="headerName" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">Name of message header to set a new value</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="setPropertyDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputExpressionNode">
        <xs:sequence/>
        <xs:attribute name="propertyName" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">Name of exchange property to set a new value</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="sortDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputExpressionNode">
        <xs:sequence/>
        <xs:attribute name="comparatorRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets a reference to lookup for the comparator to use for sorting</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="splitDefinition">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
        <xs:attribute name="parallelProcessing" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">If enabled then processing each splitted messages occurs concurrently. Note the caller thread will still wait until all messages has been fully processed before it continues. Its only processing the sub messages from the splitter which happens concurrently.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="strategyRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets a reference to the AggregationStrategy to be used to assemble the replies from the splitted messages into a single outgoing message from the Splitter. By default Camel will use the original incoming message to the splitter (leave it unchanged). You can also use a POJO as the AggregationStrategy</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="strategyMethodName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">This option can be used to explicit declare the method name to use when using POJOs as the AggregationStrategy.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="strategyMethodAllowNull" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">If this option is false then the aggregate method is not used if there was no data to enrich. If this option is true then null values is used as the oldExchange (when no data to enrich) when using POJOs as the AggregationStrategy</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="executorServiceRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Refers to a custom Thread Pool to be used for parallel processing. Notice if you set this option then parallel processing is automatic implied and you do not have to enable that option as well.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="streaming" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">When in streaming mode then the splitter splits the original message on-demand and each splitted message is processed one by one. This reduces memory usage as the splitter do not split all the messages first but then we do not know the total size and therefore the link org.apache.camel.ExchangeSPLIT_SIZE is empty. In non-streaming mode (default) the splitter will split each message first to know the total size and then process each message one by one. This requires to keep all the splitted messages in memory and therefore requires more memory. The total size is provided in the link org.apache.camel.ExchangeSPLIT_SIZE header. The streaming mode also affects the aggregation behavior. If enabled then Camel will process replies out-of-order eg in the order they come back. If disabled Camel will process replies in the same order as the messages was splitted.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="stopOnException" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Will now stop further processing if an exception or failure occurred during processing of an org.apache.camel.Exchange and the caused exception will be thrown. Will also stop if processing the exchange failed (has a fault message) or an exception was thrown and handled by the error handler (such as using onException). In all situations the splitter will stop further processing. This is the same behavior as in pipeline which is used by the routing engine. The default behavior is to not stop but continue processing till the end</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="timeout" type="xs:long">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets a total timeout specified in millis when using parallel processing. If the Splitter hasn't been able to split and process all the sub messages within the given timeframe then the timeout triggers and the Splitter breaks out and continues. Notice if you provide a TimeoutAwareAggregationStrategy then the timeout method is invoked before breaking out. If the timeout is reached with running tasks still remaining certain tasks for which it is difficult for Camel to shut down in a graceful manner may continue to run. So use this option with a bit of care.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="onPrepareRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Uses the Processor when preparing the org.apache.camel.Exchange to be send. This can be used to deep-clone messages that should be send or any custom logic needed before the exchange is send.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="shareUnitOfWork" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Shares the org.apache.camel.spi.UnitOfWork with the parent and each of the sub messages. Splitter will by default not share unit of work between the parent exchange and each splitted exchange. This means each splitted exchange has its own individual unit of work.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="parallelAggregate" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">If enabled then the aggregate method on AggregationStrategy can be called concurrently. Notice that this would require the implementation of AggregationStrategy to be implemented as thread-safe. By default this is false meaning that Camel synchronizes the call to the aggregate method. Though in some use-cases this can be used to archive higher performance when the AggregationStrategy is implemented as thread-safe.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="stopDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="threadsDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:attribute name="executorServiceRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To refer to a custom thread pool or use a thread pool profile (as overlay)</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="poolSize" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the core pool size</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="maxPoolSize" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the maximum pool size</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="keepAliveTime" type="xs:long">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the keep alive time for idle threads</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="timeUnit" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the keep alive time unit. By default SECONDS is used.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="maxQueueSize" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the maximum number of tasks in the work queue. Use -1 or Integer.MAX_VALUE for an unbounded queue</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="allowCoreThreadTimeOut" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether idle core threads is allowed to timeout and therefore can shrink the pool size below the core pool size Is by default false</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="threadName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the thread name to use.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="rejectedPolicy" type="tns:threadPoolRejectedPolicy">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the handler for tasks which cannot be executed by the thread pool.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="callerRunsWhenRejected" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether or not the caller should run the task when it was rejected by the thread pool. Is by default true</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="throttleDefinition">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
        <xs:attribute name="executorServiceRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the ExecutorService which could be used by throttle definition</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="timePeriodMillis" type="xs:long">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the time period during which the maximum request count is valid for</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="asyncDelayed" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Enables asynchronous delay which means the thread will no block while delaying.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="callerRunsWhenRejected" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether or not the caller should run the task when it was rejected by the thread pool. Is by default true</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="rejectExecution" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether or not throttler throws the ThrottlerRejectedExecutionException when the exchange exceeds the request limit Is by default false</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="throwExceptionDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">Reference to the exception instance to lookup from the registry to throw</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="transactedDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets a reference to use for lookup the policy in the registry.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="transformDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputExpressionNode">
        <xs:sequence/>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="tryDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="unmarshalDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence>
          <xs:choice minOccurs="0">
            <xs:element ref="tns:avro"/>
            <xs:element ref="tns:base64"/>
            <xs:element ref="tns:beanio"/>
            <xs:element ref="tns:bindy"/>
            <xs:element ref="tns:castor"/>
            <xs:element ref="tns:crypto"/>
            <xs:element ref="tns:csv"/>
            <xs:element name="custom" type="tns:customDataFormat"/>
            <xs:element ref="tns:flatpack"/>
            <xs:element ref="tns:gzip"/>
            <xs:element ref="tns:hl7"/>
            <xs:element ref="tns:ical"/>
            <xs:element ref="tns:jaxb"/>
            <xs:element ref="tns:jibx"/>
            <xs:element ref="tns:json"/>
            <xs:element ref="tns:protobuf"/>
            <xs:element ref="tns:rss"/>
            <xs:element ref="tns:secureXML"/>
            <xs:element ref="tns:serialization"/>
            <xs:element ref="tns:soapjaxb"/>
            <xs:element ref="tns:string"/>
            <xs:element ref="tns:syslog"/>
            <xs:element ref="tns:tidyMarkup"/>
            <xs:element ref="tns:univocity-csv"/>
            <xs:element ref="tns:univocity-fixed"/>
            <xs:element ref="tns:univocity-tsv"/>
            <xs:element ref="tns:xmlBeans"/>
            <xs:element ref="tns:xmljson"/>
            <xs:element ref="tns:xmlrpc"/>
            <xs:element ref="tns:xstream"/>
            <xs:element ref="tns:pgp"/>
            <xs:element ref="tns:zip"/>
            <xs:element ref="tns:zipFile"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="ref" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To refer to a custom data format to use as unmarshaller</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="validateDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputExpressionNode">
        <xs:sequence/>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="whenSkipSendToEndpointDefinition">
    <xs:complexContent>
      <xs:extension base="tns:whenDefinition">
        <xs:sequence/>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="wireTapDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence>
          <xs:element minOccurs="0" name="body" type="tns:expressionSubElementDefinition"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:setHeader"/>
        </xs:sequence>
        <xs:attribute name="uri" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Uri of the endpoint to use as wire tap</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ref" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Reference of the endpoint to use as wire tap</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="processorRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Reference to a Processor to use for creating a new body as the message to use for wire tapping</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="executorServiceRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Uses a custom thread pool</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="copy" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Uses a copy of the original exchange</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="onPrepareRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Uses the Processor when preparing the org.apache.camel.Exchange to be send. This can be used to deep-clone messages that should be send or any custom logic needed before the exchange is send.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="constantExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="elExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="exchangePropertyExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="groovyExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="headerExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="jxPathExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression">
        <xs:attribute name="lenient" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Allows to turn lenient on the JXPathContext. When turned on this allows the JXPath expression to evaluate against expressions and message bodies which may be invalid / missing data. This option is by default false</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="javaScriptExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="jsonPathExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression">
        <xs:attribute name="resultType" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the class name of the result type (type from output)</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="languageExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression">
        <xs:attribute name="language" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">The name of the language to use</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="methodCallExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression">
        <xs:attribute name="bean" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Either a reference or a class name of the bean to use</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ref" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Reference to bean to lookup in the registry</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="method" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Name of method to call</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="beanType" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Class name of the bean to use</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="mvelExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="namespaceAwareExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="ognlExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="phpExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="pythonExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="refExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="rubyExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="simpleExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression">
        <xs:attribute name="resultType" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the class name of the result type (type from output)</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="spELExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="sqlExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="terserExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="tokenizerExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression">
        <xs:attribute name="token" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en">The (start) token to use as tokenizer for example \n for a new line token</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="endToken" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The end token to use as tokenizer if using start/end token pairs.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="inheritNamespaceTagName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To inherit namepaces from a root/parent tag name</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="headerName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Name of header to tokenize instead of using the message body.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="regex" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">If the token is a regular expression pattern. The default value is false</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="xml" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether the input is XML messages. This option must be set to true if working with XML payloads.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="includeTokens" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to include the tokens in the parts The default value is false</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="group" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en">To group N parts together for example to split big files into chunks of 1000 lines.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="vtdXmlExpression">
    <xs:simpleContent>
      <xs:extension base="tns:namespaceAwareExpression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="xmlTokenizerExpression">
    <xs:simpleContent>
      <xs:extension base="tns:namespaceAwareExpression">
        <xs:attribute name="headerName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Name of header to tokenize instead of using the message body.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="mode" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The extraction mode. The available extraction modes are: i - injecting the contextual namespace bindings into the extracted token (default) w - wrapping the extracted token in its ancestor context u - unwrapping the extracted token to its child content t - extracting the text content of the specified element</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="group" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en">To group N parts together</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="xPathExpression">
    <xs:simpleContent>
      <xs:extension base="tns:namespaceAwareExpression">
        <xs:attribute name="documentType" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Name of class for document type The default value is org.w3c.dom.Document</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="resultType" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the class name of the result type (type from output) The default result type is NodeSet</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="saxon" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to use Saxon.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="factoryRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">References to a custom XPathFactory to lookup in the registry</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="objectModel" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">The XPath object model to use</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="logNamespaces" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to log namespaces which can assist during trouble shooting</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="headerName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Name of header to use as input instead of the message body</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="xQueryExpression">
    <xs:simpleContent>
      <xs:extension base="tns:namespaceAwareExpression">
        <xs:attribute name="type" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the class name of the result type (type from output) The default result type is NodeSet</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="headerName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Name of header to use as input instead of the message body</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="deleteVerbDefinition">
    <xs:complexContent>
      <xs:extension base="tns:verbDefinition">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="getVerbDefinition">
    <xs:complexContent>
      <xs:extension base="tns:verbDefinition">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="headVerbDefinition">
    <xs:complexContent>
      <xs:extension base="tns:verbDefinition">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="postVerbDefinition">
    <xs:complexContent>
      <xs:extension base="tns:verbDefinition">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="putVerbDefinition">
    <xs:complexContent>
      <xs:extension base="tns:verbDefinition">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="restBindingDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="consumes" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To define the content type what the REST service consumes (accept as input) such as application/xml or application/json</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="produces" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">To define the content type what the REST service produces (uses for output) such as application/xml or application/json</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="bindingMode" type="tns:restBindingMode">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the binding mode to use. The default value is auto</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="type" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the class name to use for binding from input to POJO for the incoming data</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="outType" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en">Sets the class name to use for binding from POJO to output for the outgoing data</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="skipBindingOnErrorCode" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc as success messages otherwise will do.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="enableCORS" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en">Whether to enable CORS headers in the HTTP response. The default value is false.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:anyAttribute namespace="##other" processContents="skip"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="restsDefinition">
    <xs:complexContent>
      <xs:extension base="tns:optionalIdentifiedDefinition">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:rest"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="keyManagersParametersFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractKeyManagersParametersFactoryBean">
        <xs:sequence>
          <xs:element minOccurs="0" name="keyStore" type="tns:keyStoreParametersFactoryBean"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="keyStoreParametersFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractKeyStoreParametersFactoryBean">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="sslContextClientParametersFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractJsseUtilFactoryBean">
        <xs:all>
          <xs:element minOccurs="0" name="cipherSuites" type="tns:cipherSuitesParameters"/>
          <xs:element minOccurs="0" name="cipherSuitesFilter" type="tns:filterParameters"/>
          <xs:element minOccurs="0" name="secureSocketProtocols" type="tns:secureSocketProtocolsParameters"/>
          <xs:element minOccurs="0" name="secureSocketProtocolsFilter" type="tns:filterParameters"/>
        </xs:all>
        <xs:attribute name="sessionTimeout" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="sslContextParametersFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractJsseUtilFactoryBean">
        <xs:all>
          <xs:element minOccurs="0" name="cipherSuites" type="tns:cipherSuitesParameters"/>
          <xs:element minOccurs="0" name="cipherSuitesFilter" type="tns:filterParameters"/>
          <xs:element minOccurs="0" name="secureSocketProtocols" type="tns:secureSocketProtocolsParameters"/>
          <xs:element minOccurs="0" name="secureSocketProtocolsFilter" type="tns:filterParameters"/>
          <xs:element minOccurs="0" name="keyManagers" type="tns:keyManagersParametersFactoryBean"/>
          <xs:element minOccurs="0" name="trustManagers" type="tns:trustManagersParametersFactoryBean"/>
          <xs:element minOccurs="0" name="secureRandom" type="tns:secureRandomParametersFactoryBean"/>
          <xs:element minOccurs="0" name="clientParameters" type="tns:sslContextClientParametersFactoryBean"/>
          <xs:element minOccurs="0" name="serverParameters" type="tns:sslContextServerParametersFactoryBean"/>
        </xs:all>
        <xs:attribute name="sessionTimeout" type="xs:string"/>
        <xs:attribute name="provider" type="xs:string"/>
        <xs:attribute name="secureSocketProtocol" type="xs:string"/>
        <xs:attribute name="certAlias" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="trustManagersParametersFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractTrustManagersParametersFactoryBean">
        <xs:sequence>
          <xs:element minOccurs="0" name="keyStore" type="tns:keyStoreParametersFactoryBean"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="secureRandomParametersFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractSecureRandomParametersFactoryBean">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="sslContextServerParametersFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractJsseUtilFactoryBean">
        <xs:all>
          <xs:element minOccurs="0" name="cipherSuites" type="tns:cipherSuitesParameters"/>
          <xs:element minOccurs="0" name="cipherSuitesFilter" type="tns:filterParameters"/>
          <xs:element minOccurs="0" name="secureSocketProtocols" type="tns:secureSocketProtocolsParameters"/>
          <xs:element minOccurs="0" name="secureSocketProtocolsFilter" type="tns:filterParameters"/>
        </xs:all>
        <xs:attribute name="sessionTimeout" type="xs:string"/>
        <xs:attribute name="clientAuthentication" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:simpleType name="shutdownRoute">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Default"/>
      <xs:enumeration value="Defer"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="shutdownRunningTask">
    <xs:restriction base="xs:string">
      <xs:enumeration value="CompleteCurrentTaskOnly"/>
      <xs:enumeration value="CompleteAllTasks"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="errorHandlerType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="DefaultErrorHandler"/>
      <xs:enumeration value="DeadLetterChannel"/>
      <xs:enumeration value="NoErrorHandler"/>
      <xs:enumeration value="LoggingErrorHandler"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="loggingLevel">
    <xs:restriction base="xs:string">
      <xs:enumeration value="DEBUG"/>
      <xs:enumeration value="TRACE"/>
      <xs:enumeration value="INFO"/>
      <xs:enumeration value="OFF"/>
      <xs:enumeration value="WARN"/>
      <xs:enumeration value="ERROR"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="threadPoolRejectedPolicy">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Abort"/>
      <xs:enumeration value="Discard"/>
      <xs:enumeration value="DiscardOldest"/>
      <xs:enumeration value="CallerRuns"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="exchangePattern">
    <xs:restriction base="xs:string">
      <xs:enumeration value="RobustOutOnly"/>
      <xs:enumeration value="InOut"/>
      <xs:enumeration value="OutOptionalIn"/>
      <xs:enumeration value="InOptionalOut"/>
      <xs:enumeration value="InOnly"/>
      <xs:enumeration value="OutOnly"/>
      <xs:enumeration value="RobustInOnly"/>
      <xs:enumeration value="OutIn"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="bindyType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="KeyValue"/>
      <xs:enumeration value="Fixed"/>
      <xs:enumeration value="Csv"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="jsonLibrary">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Gson"/>
      <xs:enumeration value="Jackson"/>
      <xs:enumeration value="XStream"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="onCompletionMode">
    <xs:restriction base="xs:string">
      <xs:enumeration value="BeforeConsumer"/>
      <xs:enumeration value="AfterConsumer"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="restHostNameResolver">
    <xs:restriction base="xs:string">
      <xs:enumeration value="localHostName"/>
      <xs:enumeration value="localIp"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="restBindingMode">
    <xs:restriction base="xs:string">
      <xs:enumeration value="off"/>
      <xs:enumeration value="auto"/>
      <xs:enumeration value="json"/>
      <xs:enumeration value="xml"/>
      <xs:enumeration value="json_xml"/>
    </xs:restriction>
  </xs:simpleType>
</xs:schema>
