<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Servlet</title><link rel="stylesheet" type="text/css" href="eclipse_book.css"><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"><meta name="keywords" content="Apache Camel, Open Source, open source, Fuse, Red Hat, EIP, Enterprise Integration Patterns"><meta name="keywords" content="Apache Camel, Open Source, open source, Fuse, Red Hat, EIP, Enterprise Integration Patterns"><link rel="home" href="index.html" title="Red Hat JBoss Fuse Tooling for Eclipse"><link rel="up" href="RiderHTTPEptRef.html" title="HTTP Endpoints"><link rel="prev" href="restlet.html" title="Restlet"><link rel="next" href="RiderIntEptRef.html" title="Internal Endpoints"><link rel="copyright" href="tmdisclaim.html" title="Trademark Disclaimer"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="refentry"><a name="servlet"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>Servlet &#8212; provides support for HTTP endpoints that are published as servlets</p></div><div class="refsection"><a name="d0e37665"></a><h2>Overview</h2><p>The <span class="bold"><strong>servlet:</strong></span> component provides HTTP-based <a class="link" href="Endpoint" target="_top">endpoints</a> for consuming HTTP requests that arrive at a
            HTTP endpoint, and this endpoint is bound to a published Servlet.</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="imagesdb/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>You can only consume from endpoints generated by the Servlet component. Therefore, it
            should only be used as input into your Apache Camel routes. To issue HTTP requests
            against other HTTP endpoints, use the <a href="PLUGINS_ROOT/com.fusesource.rider.help/http.html" class="olink">HTTP Component</a>.</p></td></tr></table></div></div><div class="refsection"><a name="d0e37682"></a><h2>URI format</h2><p>The URI format of a Servlet endpoint is:</p><pre class="programlisting">servlet://<em class="replaceable"><code>relative_path</code></em>[?<em class="replaceable"><code>options</code></em>]</pre><p>You can append query options to the URI in the following format,
            <code class="literal">?option=value&amp;option=value&amp;...</code></p></div><div class="refsection"><a name="d0e37699"></a><h2>Dependencies</h2><p>Maven users will need to add the following dependency to their
                <code class="literal">pom.xml</code> for this component:</p><div class="example"><a name="d0e37707"></a><p class="title"><b>Example&nbsp;8.&nbsp;Adding the servlet dependency</b></p><div class="example-contents"><pre class="programlisting"><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.apache.camel<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>camel-servlet<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;version&gt;</strong>x.x.x<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
    <em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">&lt;!-- use the same version as your Camel core version --&gt;</em>
<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong></pre></div></div><br class="example-break"></div><div class="refsection"><a name="d0e37713"></a><h2>Options</h2><p><a class="xref" href="servlet.html#ServletRefOptsTbl" title="Table&nbsp;31.&nbsp;Servlet endpoint options">Table&nbsp;31, &#8220;Servlet endpoint options&#8221;</a> lists the options for a Servlet endpoint.</p><div class="table"><a name="ServletRefOptsTbl"></a><p class="title"><b>Table&nbsp;31.&nbsp;Servlet endpoint options</b></p><div class="table-contents"><table summary="Servlet endpoint options" width="100%" border="1"><colgroup><col width="20%" class="c1"><col width="9%" class="c2"><col width="71%" class="c3"></colgroup><thead><tr><th>Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>
                            <code class="code">httpBindingRef</code>
                        </td><td><code class="literal">null</code></td><td>Specifies a reference to an
                                <code class="code">org.apache.camel.component.http.HttpBinding</code> in the
                            registry. You can use an <code class="code">HttpBinding</code> implementation to
                            customize how to write a response.</td></tr><tr><td>
                            <code class="code">matchOnUriPrefix</code>
                        </td><td>
                            <code class="literal">false</code>
                        </td><td>Specifies whether the <code class="code">CamelServlet</code> should try to find a
                            target consumer by matching the URI prefix when no exact match is
                            found.</td></tr><tr><td>
                            <code class="code">servletName</code>
                        </td><td><code class="literal">null</code></td><td>Specifies the servlet name that the endpoint will bind to. If no
                            servlet name is specified, the endpoint binds to the first
                            published Servlet.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsection"><a name="d0e37779"></a><h2>Message headers</h2><p>Apache Camel applies the same Message Headers as the <a href="PLUGINS_ROOT/com.fusesource.rider.help/http.html" class="olink">HTTP</a> component.</p><p>Apache Camel also populates <span class="bold"><strong>all</strong></span>
            <code class="literal">request.parameter</code> and <code class="literal">request.headers</code>. For
            example, if a client request has the URL,
                <code class="literal">http://myserver/myserver?orderid=123</code>, the exchange will contain a
            header named <code class="literal">orderid</code> with the value 123. </p></div><div class="refsection"><a name="_IDU_SERVLET_HSH_PuttingCamelJARsintheappserverbootclasspath"></a><h2>Putting Camel JARs in the app server boot classpath</h2><p>If you put the Camel JARs such as <code class="literal">camel-core</code>,
                <code class="literal">camel-servlet</code>, etc. in the boot classpath of
            your application server (eg usually in its lib directory), then mind
            that the servlet mapping list is now shared between multiple
            deployed Camel application in the app server.</p><p>Mind that putting Camel JARs in the boot classpath of the
            application server is generally not best practice!</p><p>So in those situations you <span class="bold"><strong>must</strong></span>
            define a custom and unique servlet name in each of your Camel
            application, eg in the <code class="literal">web.xml</code> define:</p><pre class="programlisting">
&lt;servlet&gt;
  &lt;servlet-name&gt;MySerlvet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.apache.camel.component.servlet.CamelHttpTransportServlet&lt;/servlet-class&gt;
  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</pre><p>And in your Camel endpoints then include the servlet name as
            well</p><pre class="programlisting">
&lt;route&gt;
  &lt;from uri="servlet://foo?servletName=MyServlet"/&gt;
  ...
&lt;/route&gt;
</pre><p>From <span class="bold"><strong>Apache Camel 2.11</strong></span> onwards Camel will detect this
            duplicate and fail to start the application. You can control to ignore this duplicate by
            setting the servlet init-parameter ignoreDuplicateServletName to true as follows:</p><pre class="programlisting">
  &lt;servlet&gt;
    &lt;servlet-name&gt;CamelServlet&lt;/servlet-name&gt;
    &lt;display-name&gt;Camel Http Transport Servlet&lt;/display-name&gt;
    &lt;servlet-class&gt;org.apache.camel.component.servlet.CamelHttpTransportServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;ignoreDuplicateServletName&lt;/param-name&gt;
      &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/servlet&gt;
</pre><p>But its <span class="bold"><strong>strongly advised</strong></span> to use
            unique servlet-name for each Camel application to avoid this
            duplication clash, as well any unforeseen side-effects.</p></div><div class="refsection"><a name="_IDU_SERVLET_HSH_Sample"></a><h2>Sample</h2><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="imagesdb/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>From <span class="bold"><strong>Apache Camel 2.7</strong></span> onwards its easier to use
                    <span class="olink">Servlet</span> in Spring web applications. See
                    <a class="link" href="Servlet Tomcat Example" target="_top">Servlet Tomcat Example</a> for
                details.</p></td></tr></table></div><p>In this sample, we define a route that exposes a HTTP service at
                <code class="literal">http://localhost:8080/camel/services/hello</code>.
            First, you need to publish the <a class="link" href="http://svn.apache.org/repos/asf/camel/trunk/components/camel-servlet/src/main/java/org/apache/camel/component/servlet/CamelHttpTransportServlet.java" target="_top">CamelHttpTransportServlet</a> through the normal Web
            Container, or OSGi Service. Use the <code class="literal">Web.xml</code> file
            to publish the <a class="link" href="http://svn.apache.org/repos/asf/camel/trunk/components/camel-servlet/src/main/java/org/apache/camel/component/servlet/CamelHttpTransportServlet.java" target="_top">CamelHttpTransportServlet</a> as follows:</p><pre class="programlisting">&lt;web-app&gt;

  &lt;servlet&gt;
    &lt;servlet-name&gt;CamelServlet&lt;/servlet-name&gt;
    &lt;display-name&gt;Camel Http Transport Servlet&lt;/display-name&gt;
    &lt;servlet-class&gt;
        org.apache.camel.component.servlet.CamelHttpTransportServlet
    &lt;/servlet-class&gt;
    
  &lt;/servlet&gt;

  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;CamelServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/services/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;

&lt;/web-app&gt;</pre><p>Then you can define your route as follows:</p><pre class="programlisting">from("servlet:///hello?matchOnUriPrefix=true").process(new Processor() {
    public void process(Exchange exchange) throws Exception {                    
        String contentType = exchange.getIn().getHeader(Exchange.CONTENT_TYPE, String.class);
        String path = exchange.getIn().getHeader(Exchange.HTTP_URI, String.class);
        path = path.substring(path.lastIndexOf("/"));

        assertEquals("Get a wrong content type", CONTENT_TYPE, contentType);
        // assert camel http header
        String charsetEncoding = exchange.getIn().getHeader(Exchange.HTTP_CHARACTER_ENCODING, String.class);
        assertEquals("Get a wrong charset name from the message heaer", "UTF-8", charsetEncoding);
        // assert exchange charset
        assertEquals("Get a wrong charset naem from the exchange property", "UTF-8", exchange.getProperty(Exchange.CHARSET_NAME));
        exchange.getOut().setHeader(Exchange.CONTENT_TYPE, contentType + "; charset=UTF-8");                        
        exchange.getOut().setHeader("PATH", path);
        exchange.getOut().setBody("&lt;b&gt;Hello World&lt;/b&gt;");
    }
});</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="imagesdb/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Since we are binding the Http transport with a published
                servlet, and we don't know the servlet's application context
                path, the <code class="literal">camel-servlet</code> endpoint uses the
                relative path to specify the endpoint's URL. A client can access
                the <code class="literal">camel-servlet</code> endpoint through the
                servlet publish address:
                    <code class="literal">("http://localhost:8080/camel/services") +
                    RELATIVE_PATH("/hello")</code>.</p></td></tr></table></div></div><div class="refsection"><a name="_IDU_SERVLET_HSH_SamplewhenusingSpring3x"></a><h2>Sample when using Spring 3.x</h2><p>The standalone Apache Camel package contains a demonstration of how to
            deploy the Servlet component in the Tomcat Web container. The
            demonstration is located in the
                <code class="code">examples/camel-example-servlet-tomcat</code> directory.
            When deploying a Servlet component in the Web container, it is
            necessary to create a Spring application context explicitly by
            creating a Spring <code class="literal">ContextLoaderListener</code> instance
            in the <code class="code">WEB-INF/web.xml</code> file.</p><p>For example, to create a Spring application context that loads
            Spring definitions (including the <code class="code">camelContext</code> and
            route definitions) from the <code class="code">camel-config.xml</code> file,
            define a <code class="code">web.xml</code> file as follows:</p><pre class="programlisting">&lt;web-app version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;

    &lt;display-name&gt;My Web Application&lt;/display-name&gt;

    &lt;!-- location of spring xml files --&gt;
<span class="bold"><strong>    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:camel-config.xml&lt;/param-value&gt;
    &lt;/context-param&gt;</strong></span>

    &lt;!-- the listener that kick-starts Spring --&gt;
<span class="bold"><strong>    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;</strong></span>

    &lt;!-- Camel servlet --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;CamelServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.apache.camel.component.servlet.CamelHttpTransportServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;!-- Camel servlet mapping --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;CamelServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/camel/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;</pre></div><div class="refsection"><a name="_IDU_SERVLET_HSH_SamplewhenusingSpring2x"></a><h2>Sample when using Spring 2.x</h2><p>When using the Servlet component in a Camel/Spring application
            it's often required to load the Spring ApplicationContext
                <span class="emphasis"><em>after</em></span> the Servlet component has started.
            This can be accomplished by using Spring's
                <code class="literal">ContextLoaderServlet</code> instead of
                <code class="literal">ContextLoaderListener</code>. In that case you'll
            need to start <code class="literal">ContextLoaderServlet</code> after <a class="link" href="http://svn.apache.org/repos/asf/camel/trunk/components/camel-servlet/src/main/java/org/apache/camel/component/servlet/CamelHttpTransportServlet.java" target="_top">CamelHttpTransportServlet</a> like this:</p><pre class="programlisting">&lt;web-app&gt;
  &lt;servlet&gt; 
        &lt;servlet-name&gt;CamelServlet&lt;/servlet-name&gt; 
        &lt;servlet-class&gt; 
            org.apache.camel.component.servlet.CamelHttpTransportServlet 
        &lt;/servlet-class&gt; 
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; 
  &lt;/servlet&gt; 
  &lt;servlet&gt; 
        &lt;servlet-name&gt;SpringApplicationContext&lt;/servlet-name&gt; 
        &lt;servlet-class&gt; 
            org.springframework.web.context.ContextLoaderServlet 
        &lt;/servlet-class&gt; 
        &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; 
  &lt;/servlet&gt; 
&lt;web-app&gt;</pre></div><div class="refsection"><a name="_IDU_SERVLET_HSH_SamplewhenusingOSGi"></a><h2>Sample when using OSGi</h2><p>From <span class="bold"><strong>Apache Camel 2.6.0</strong></span>, you can publish the <a class="link" href="http://svn.apache.org/repos/asf/camel/trunk/components/camel-servlet/src/main/java/org/apache/camel/component/servlet/CamelHttpTransportServlet.java" target="_top">CamelHttpTransportServlet</a> as an OSGi service with help of SpringDM like
            this.</p><pre class="programlisting">&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:osgi="http://www.springframework.org/schema/osgi"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/osgi  http://www.springframework.org/schema/osgi/spring-osgi.xsd"&gt;
    
    &lt;bean id="camelServlet" class="org.apache.camel.component.servlet.CamelHttpTransportServlet"&gt;
    &lt;/bean&gt;
    
    &lt;!-- 
        Enlist it in OSGi service registry 
        This will cause two things:
        1) As the pax web whiteboard extender is running the CamelServlet will
           be registered with the OSGi HTTP Service
        2) It will trigger the HttpRegistry in other bundles so the servlet is
           made known there too
    --&gt;
    &lt;osgi:service ref="camelServlet"&gt;
        &lt;osgi:interfaces&gt;
            &lt;value&gt;javax.servlet.Servlet&lt;/value&gt;
            &lt;value&gt;org.apache.camel.component.http.CamelServlet&lt;/value&gt;
        &lt;/osgi:interfaces&gt;
        &lt;osgi:service-properties&gt;
            &lt;entry key="alias" value="/camel/services" /&gt;
            &lt;entry key="matchOnUriPrefix" value="true" /&gt;
            &lt;entry key="servlet-name" value="CamelServlet"/&gt;
        &lt;/osgi:service-properties&gt;
    &lt;/osgi:service&gt;

&lt;/beans&gt;</pre><p>Then use this service in your camel route like this:</p><pre class="programlisting">&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:camel="http://camel.apache.org/schema/spring"
       xmlns:osgi="http://www.springframework.org/schema/osgi"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/osgi  http://www.springframework.org/schema/osgi/spring-osgi.xsd
       http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd"&gt;

    &lt;osgi:reference id="servletref" interface="org.apache.camel.component.http.CamelServlet"&gt;
          &lt;osgi:listener bind-method="register" unbind-method="unregister"&gt;
             &lt;ref bean="httpRegistry"/&gt;
          &lt;/osgi:listener&gt;
    &lt;/osgi:reference&gt;
    
    &lt;bean id="httpRegistry" class="org.apache.camel.component.servlet.DefaultHttpRegistry"/&gt;
        
    &lt;bean id="servlet" class="org.apache.camel.component.servlet.ServletComponent"&gt;
        &lt;property name="httpRegistry" ref="httpRegistry" /&gt;
    &lt;/bean&gt;

    &lt;bean id="servletProcessor" class="org.apache.camel.itest.osgi.servlet.ServletProcessor" /&gt;

    &lt;camelContext xmlns="http://camel.apache.org/schema/spring"&gt;
        &lt;route&gt;
            &lt;!-- notice how we can use the servlet scheme which is that osgi:reference above --&gt;
            &lt;from uri="servlet:///hello"/&gt;
            &lt;process ref="servletProcessor"/&gt;
        &lt;/route&gt;
    &lt;/camelContext&gt;

&lt;/beans&gt;</pre><p>Alternatively - pre Camel 2.6 - you can use an
                <code class="literal">Activator</code> to publish the <a class="link" href="http://svn.apache.org/repos/asf/camel/trunk/components/camel-servlet/src/main/java/org/apache/camel/component/servlet/CamelHttpTransportServlet.java" target="_top">CamelHttpTransportServlet</a> on the OSGi platform </p><pre class="programlisting">import java.util.Dictionary;
import java.util.Hashtable;

import org.apache.camel.component.servlet.CamelHttpTransportServlet;
import org.osgi.framework.BundleActivator;
import org.osgi.framework.BundleContext;
import org.osgi.framework.ServiceReference;
import org.osgi.service.http.HttpContext;
import org.osgi.service.http.HttpService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.osgi.context.BundleContextAware;

public final class ServletActivator implements BundleActivator, BundleContextAware {
    private static final transient Logger LOG = LoggerFactory.getLogger(ServletActivator.class);
    private static boolean registerService;
    
    /**
     * HttpService reference.
     */
    private ServiceReference httpServiceRef;
    
    /**
     * Called when the OSGi framework starts our bundle
     */
    public void start(BundleContext bc) throws Exception {
        registerServlet(bc);
    }

    /**
     * Called when the OSGi framework stops our bundle
     */
    public void stop(BundleContext bc) throws Exception {
        if (httpServiceRef != null) {
            bc.ungetService(httpServiceRef);
            httpServiceRef = null;
        }
    }
    
    protected void registerServlet(BundleContext bundleContext) throws Exception {
        httpServiceRef = bundleContext.getServiceReference(HttpService.class.getName());
        
        if (httpServiceRef != null &amp;&amp; !registerService) {
            LOG.info("Register the servlet service");
            final HttpService httpService = (HttpService)bundleContext.getService(httpServiceRef);
            if (httpService != null) {
                // create a default context to share between registrations
                final HttpContext httpContext = httpService.createDefaultHttpContext();
                // register the hello world servlet
                final Dictionary&lt;String, String&gt; initParams = new Hashtable&lt;String, String&gt;();
                initParams.put("matchOnUriPrefix", "false");
                initParams.put("servlet-name", "CamelServlet");
                httpService.registerServlet("/camel/services", // alias
                    new CamelHttpTransportServlet(), // register servlet
                    initParams, // init params
                    httpContext // http context
                );
                registerService = true;
            }
        }
    }

    public void setBundleContext(BundleContext bc) {
        try {
            registerServlet(bc);
        } catch (Exception e) {
            LOG.error("Cannot register the servlet, the reason is " + e);
        }
    }

}</pre></div><div class="refsection"><a name="d0e37972"></a><h2>Related topics</h2><table border="0" summary="Simple list" class="simplelist"><tr><td>
                <a href="PLUGINS_ROOT/com.fusesource.rider.help/http.html" class="olink">HTTP</a>
            </td></tr><tr><td>
                <a href="PLUGINS_ROOT/com.fusesource.rider.help/http4.html" class="olink">HTTP4</a>
            </td></tr></table></div></div></body></html>