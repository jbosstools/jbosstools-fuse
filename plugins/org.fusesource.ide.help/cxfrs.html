<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>CXF REST</title><link rel="stylesheet" type="text/css" href="eclipse_book.css"><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"><meta name="keywords" content="Apache Camel, Open Source, open source, Fuse, Red Hat, EIP, Enterprise Integration Patterns"><meta name="keywords" content="Apache Camel, Open Source, open source, Fuse, Red Hat, EIP, Enterprise Integration Patterns"><link rel="home" href="index.html" title="Red Hat JBoss Fuse Tooling for Eclipse"><link rel="up" href="cxf.html" title="Apache CXF Endpoints"><link rel="prev" href="cxfBeanComp.html" title="CXF Bean"><link rel="next" href="RiderFileEptRef.html" title="File Endpoints"><link rel="copyright" href="tmdisclaim.html" title="Trademark Disclaimer"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="refentry"><a name="cxfrs"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>CXF REST &#8212; provides integration for linking with JAX-RS based RESTful services</p></div><div class="refsection"><a name="d0e29062"></a><h2>Overview</h2><p>The <code class="literal">cxfrs:</code> component provides integration with <a class="link" href="http://incubator.apache.org/cxf/" target="_top">Apache CXF</a> for connecting to
            JAX-RS services hosted in CXF.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="imagesdb/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>When using CXF as a consumer, the <a href="PLUGINS_ROOT/com.fusesource.rider.help/cxfBeanComp.html" class="olink">CAMEL:CXF Bean
                    Component</a> allows you to factor out how message payloads are received
                from their processing as a RESTful or SOAP web service. This provides the
                possibility of using a multitude of transports to consume web services. The bean
                component's configuration is also simpler and provides the fastest method to
                implement web services using Camel and CXF.</p></td></tr></table></div></div><div class="refsection"><a name="d0e29079"></a><h2>Dependencies</h2><p>Maven users need to add the following dependency to their <code class="code">pom.xml</code> for
            this component:</p><pre class="programlisting">&lt;dependency&gt;
   &lt;groupId&gt;org.apache.camel&lt;/groupId&gt;
   &lt;artifactId&gt;camel-cxf&lt;/artifactId&gt;
   &lt;version&gt;x.x.x&lt;/version&gt;  &lt;!-- use the same version as your Camel core version --&gt;
&lt;/dependency&gt;</pre></div><div class="refsection"><a name="d0e29089"></a><h2>URI format</h2><p>CXF REST endpoints support two URI formats:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><pre class="programlisting">cxfrs://<em class="replaceable"><code>address</code></em>?<em class="replaceable"><code>options</code></em></pre><p>Where <em class="replaceable"><code>address</code></em> represents the CXF endpoint's
                    address</p></li><li class="listitem"><pre class="programlisting">cxfrs:bean:<em class="replaceable"><code>rsEndpoint</code></em></pre><p>Where <em class="replaceable"><code>rsEndpoint</code></em> represents the Spring bean's name
                    which represents the CXFRS client or server</p></li></ul></div><p>Using either format, you can append options to the URI like this:</p><pre class="programlisting">cxfrs:bean:cxfEndpoint?resourceClasses=org.apache.camel.rs.Example</pre></div><div class="refsection"><a name="d0e29122"></a><h2>Dependencies</h2><p>Maven users will need to add a dependency on <code class="code">camel-cxf</code> to their poms as
            shown in <a class="xref" href="cxfrs.html#CXFRSRefDepEx" title="Example&nbsp;2.&nbsp;Apache CXF dependency">Example&nbsp;2, &#8220;Apache CXF dependency&#8221;</a>.</p><div class="example"><a name="CXFRSRefDepEx"></a><p class="title"><b>Example&nbsp;2.&nbsp;Apache CXF dependency</b></p><div class="example-contents"><pre class="programlisting"><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.apache.camel<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>camel-cxf<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;version&gt;</strong>x.x.x<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
    <em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">&lt;!-- use the same version as your Camel core version --&gt;</em>
<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong></pre></div></div><br class="example-break"><p>If you want to learn about Apache CXF dependencies, see the <a class="link" href="http://svn.apache.org/repos/asf/cxf/trunk/distribution/src/main/release/lib/WHICH_JARS" target="_top">WHICH-JARS</a> text file.</p></div><div class="refsection"><a name="d0e29142"></a><h2>Options</h2><p><a class="xref" href="cxfrs.html#CXFRSRefOptsTbl" title="Table&nbsp;6.&nbsp;CXF REST options">Table&nbsp;6, &#8220;CXF REST options&#8221;</a> lists the options for a CXF REST endpoint. None of
            these options are required.</p><div class="table"><a name="CXFRSRefOptsTbl"></a><p class="title"><b>Table&nbsp;6.&nbsp;CXF REST options</b></p><div class="table-contents"><table summary="CXF REST options" width="100%" border="1"><colgroup><col width="50%"><col width="50%"></colgroup><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>
                            <code class="literal">resourceClasses</code>
                        </td><td><p>Specifies the resource classes you want to export as a REST service.
                            Separate multiple classes with a comma.</p>
                            <p>For example:
                                <code class="literal">resourceClasses=org.apache.camel.rs.Example1,</code>
                                <code class="literal">org.apache.camel.rs.Exchange2</code>
                            </p></td></tr><tr><td>
                            <code class="literal">httpClientAPI</code>
                        </td><td>
                            <p><span class="bold"><strong>Apache Camel 2.1 onwards:</strong></span> When true, the
                            CxfRsProducer uses the HttpClientAPI to invoke the service.</p>
                            <p>Defaults to<code class="code">true</code></p>
                            <p>For example: <code class="code">httpClientAPI=false</code></p>
                        </td></tr><tr><td>
                            <code class="code">synchronous</code>
                        </td><td>
                            <p><span class="bold"><strong>Apache Camel 2.5 onwards:</strong></span> This
                            option lets CxfRsConsumer decide to use the sync or async API to do the underlying work. When
                                false, tries to use async API.</p>
                            <p>Defaults to <code class="literal">false</code>.</p>
                            <p>For example: <code class="code">synchronous=true</code></p>
                        </td></tr><tr><td><code class="code">throwExceptionOnFailure</code></td><td>
                            <p><span class="bold"><strong>Apache Camel 2.6 onwards:</strong></span> This option
                                tells the CxfRsProducer to inspect return codes and generates an
                                Exception if the return code is larger than 207.</p>
                            <p>Defaults to <code class="code">true</code>.</p>
                            <p>For example: <code class="code">throwExceptionOnFailure=true</code></p>
                        </td></tr><tr><td><code class="literal">maxClientCacheSize</code>
                        </td><td><p><span class="bold"><strong>Apache Camel 2.6 onwards:</strong></span> This option allows you to configure the
                            maximum size of the cache.</p>
                            <p>You can set the <span class="emphasis"><em>In</em></span> message header,
                                <code class="code">CamelDestinationOverrideUrl</code>, to dynamically override
                            the target destination Web Service or REST Service defined in your
                            routes.</p>
                            <p>The implementation caches CXF clients or
                                <code class="code">ClientFactoryBean</code> in <code class="code">CxfProvider</code> and
                                <code class="code">CxfRsProvider</code>. This option allows you to configure the
                            maximum size of the cache.</p>
                            <p>Defaults to <code class="literal">10</code>.</p>
                            <p>For example: <code class="code">maxClientCacheSize=5</code></p>
                        </td></tr><tr><td>
                            <code class="literal">setDefaultBus</code>
                        </td><td>
                            <p><span class="bold"><strong>Apache Camel 2.9.0. onwards:</strong></span> Sets the
                                default bus when the CXF endpoint creates a bus by itself.</p>
                            <p>Defaults to <code class="literal">false</code>.</p>
                            <p>For example: <code class="literal">setDefaultBus=true</code></p>
                        </td></tr><tr><td>
                            <code class="literal">bus</code>
                        </td><td>
                            <p><span class="bold"><strong>Apache Camel 2.9.0. onwards:</strong></span>
                                Instructs CXF Bus Factory to create a default bus.</p>
                            <p>You use <code class="literal">\#</code> notation to reference a bus object from
                                the registry. The referenced object must be an instance of
                                    <code class="literal">org.apache.cxf.Bus</code>.</p>
                            <p>For example: <code class="literal">bus=#busName</code></p>
                        </td></tr><tr><td>
                            <code class="literal">bindingStyle</code>
                        </td><td>
                            <p><span class="bold"><strong>Apache Camel 2.11 onwards:</strong></span>. Specifies
                                how requests and responses are mapped to/from Camel. The two
                                possible values are: </p>
                                <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">SimpleConsumer</code>&#8212;See <a class="xref" href="cxfrs.html#_IDU_CXFRS_HSH_ConsumingaRESTRequestSimpleBindingStyle" title="Consuming a REST Request - Simple Binding Style">Consuming a REST Request - Simple Binding Style</a>.</p></li><li class="listitem"><p><code class="literal">Default</code> &#8212; Specifies the
                                        default style. For consumers, this passes on a
                                            <code class="literal">MessageContentsList</code> to the route,
                                        requiring low-level processing in the route. </p></li></ul></div>
                            <p>For example: <code class="literal">bindingStyle=SimpleConsumer</code></p>
                        </td></tr></tbody></table></div></div><br class="table-break"><p>You can also configure the CXF REST endpoint through the Spring configuration. Since
            there are lots of differences between the CXF REST client and CXF REST Server, we
            provide different configurations for them. Please check out the <a class="link" href="http://svn.apache.org/repos/asf/camel/trunk/components/camel-cxf/src/main/resources/schema/cxfEndpoint.xsd" target="_top">schema file</a> and <a class="link" href="http://cwiki.apache.org/CXF20DOC/jax-rs.html" target="_top">CXF REST user guide</a> for more information.</p></div><div class="refsection"><a name="_IDU_CXFRS_HSH_HowtoconfiguretheRESTendpointinCamel"></a><h2>How to configure the REST endpoint in Apache Camel</h2><p>In <a class="link" href="http://svn.apache.org/repos/asf/camel/trunk/components/camel-cxf/src/main/resources/schema/cxfEndpoint.xsd" target="_top">camel-cxf schema file</a>, there are two elements for the REST endpoint
            definition. <span class="bold"><strong>cxf:rsServer</strong></span> for REST consumer, <span class="bold"><strong>cxf:rsClient</strong></span> for REST producer. You can find a Apache Camel REST
            service route configuration example here.</p><pre class="programlisting">&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:cxf="http://camel.apache.org/schema/cxf"
       xmlns:jaxrs="http://cxf.apache.org/jaxrs"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://camel.apache.org/schema/cxf http://camel.apache.org/schema/cxf/camel-cxf.xsd
       http://cxf.apache.org/jaxrs http://cxf.apache.org/schemas/jaxrs.xsd
       http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd
    "&gt;
  &lt;!-- Defined the real JAXRS back end service  --&gt;
  &lt;jaxrs:server id="restService"
		        address="http://localhost:9002/rest" 
		        staticSubresourceResolution="true"&gt;
    &lt;jaxrs:serviceBeans&gt;
      &lt;ref bean="customerService"/&gt;
    &lt;/jaxrs:serviceBeans&gt;       
  &lt;/jaxrs:server&gt;
  
  &lt;!--bean id="jsonProvider" class="org.apache.cxf.jaxrs.provider.JSONProvider"/--&gt;

  &lt;bean id="customerService" class="org.apache.camel.component.cxf.jaxrs.testbean.CustomerService" /&gt;
   
  &lt;!-- Defined the server endpoint to create the cxf-rs consumer --&gt; 
  &lt;cxf:rsServer id="rsServer" address="http://localhost:9000/route"
    serviceClass="org.apache.camel.component.cxf.jaxrs.testbean.CustomerService" 
      loggingFeatureEnabled="true" loggingSizeLimit="20" skipFaultLogging="true"/&gt;

  &lt;!-- Defined the client endpoint to create the cxf-rs consumer --&gt;
  &lt;cxf:rsClient id="rsClient" address="http://localhost:9002/rest"
    serviceClass="org.apache.camel.component.cxf.jaxrs.testbean.CustomerService"
      loggingFeatureEnabled="true" skipFaultLogging="true"/&gt;
  
  &lt;!-- The camel route context --&gt;
  &lt;camelContext id="camel" xmlns="http://camel.apache.org/schema/spring"&gt;
    &lt;route&gt;
       &lt;from uri="cxfrs://bean://rsServer"/&gt;
       &lt;!-- We can remove this configure as the CXFRS producer is using the HttpAPI by default --&gt;
       &lt;setHeader headerName="CamelCxfRsUsingHttpAPI"&gt;
         &lt;constant&gt;True&lt;/constant&gt;        
       &lt;/setHeader&gt;
       &lt;to uri="cxfrs://bean://rsClient"/&gt;
    &lt;/route&gt;
  &lt;/camelContext&gt;
  
&lt;/beans&gt;</pre></div><div class="refsection"><a name="_IDU_CXFRS_HSH_ConsumingaRESTRequestSimpleBindingStyle"></a><h2>Consuming a REST Request - Simple Binding Style</h2><p>
            <span class="bold"><strong>Available as of Camel 2.11</strong></span>
        </p><p>The <code class="literal">Default</code> binding style is rather low-level, requiring the user
            to manually process the <code class="literal">MessageContentsList</code> object coming into the
            route. Thus, it tightly couples the route logic with the method signature and parameter
            indices of the JAX-RS operation. Somewhat inelegant, difficult and error-prone.</p><p>In contrast, the <code class="literal">SimpleConsumer</code> binding style performs the
            following mappings, in order to <span class="bold"><strong>make the request data more
                accessible</strong></span> to you within the Camel Message:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>JAX-RS Parameters (@HeaderParam, @QueryParam, etc.) are injected as IN message
                    headers. The header name matches the value of the annotation.</p></li><li class="listitem"><p>The request entity (POJO or other type) becomes the IN message body. If a
                    single entity cannot be identified in the JAX-RS method signature, it falls back
                    to the original <code class="literal">MessageContentsList</code>.</p></li><li class="listitem"><p>Binary <code class="literal">@Multipart</code> body parts become IN message attachments,
                    supporting <code class="literal">DataHandler</code>, <code class="literal">InputStream</code>,
                        <code class="literal">DataSource</code> and CXF's <code class="literal">Attachment</code>
                    class.</p></li><li class="listitem"><p>Non-binary <code class="literal">@Multipart</code> body parts are mapped as IN message
                    headers. The header name matches the Body Part name.</p></li></ul></div><p>Additionally, the following rules apply to the <span class="bold"><strong>Response
                mapping</strong></span>:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>If the message body type is different to
                        <code class="literal">javax.ws.rs.core.Response</code> (user-built response), a new
                        <code class="literal">Response</code> is created and the message body is set as the
                    entity (so long it's not null). The response status code is taken from the
                        <code class="literal">Exchange.HTTP_RESPONSE_CODE</code> header, or defaults to 200 OK
                    if not present.</p></li><li class="listitem"><p>If the message body type is equal to
                        <code class="literal">javax.ws.rs.core.Response</code>, it means that the user has
                    built a custom response, and therefore it is respected and it becomes the final
                    response.</p></li><li class="listitem"><p>In all cases, Camel headers permitted by custom or default
                        <code class="literal">HeaderFilterStrategy</code> are added to the HTTP
                    response.</p></li></ul></div></div><div class="refsection"><a name="_IDU_CXFRS_HSH_EnablingtheSimpleBindingStyle"></a><h2>Enabling the Simple Binding Style</h2><p>This binding style can be activated by setting the <code class="literal">bindingStyle</code>
            parameter in the consumer endpoint to value <code class="literal">SimpleConsumer</code>:</p><pre class="programlisting">
  from("cxfrs:bean:rsServer?bindingStyle=SimpleConsumer")
    .to("log:TEST?showAll=true");
</pre></div><div class="refsection"><a name="_IDU_CXFRS_HSH_Examplesofrequestbindingwithdifferentmethodsignatures"></a><h2>Examples of request binding with different method signatures</h2><p>Below is a list of method signatures along with the expected result from the Simple
            binding.</p><p><span class="bold"><strong><code class="literal">public Response doAction(BusinessObject
                    request);</code></strong></span> Request payload is placed in IN message body,
            replacing the original MessageContentsList.</p><p><span class="bold"><strong><code class="literal">public Response doAction(BusinessObject request,
                    @HeaderParam("abcd") String abcd, @QueryParam("defg") String
                defg);</code></strong></span> Request payload placed in IN message body, replacing the
            original MessageContentsList. Both request params mapped as IN message headers with
            names abcd and defg.</p><p><span class="bold"><strong><code class="literal">public Response doAction(@HeaderParam("abcd") String
                    abcd, @QueryParam("defg") String defg);</code></strong></span> Both request params
            mapped as IN message headers with names abcd and defg. The original MessageContentsList
            is preserved, even though it only contains the 2 parameters.</p><p><span class="bold"><strong><code class="literal">public Response doAction(@Multipart(value="body1")
                    BusinessObject request, @Multipart(value="body2") BusinessObject
                    request2);</code></strong></span> The first parameter is transferred as a header
            with name body1, and the second one is mapped as header body2. The original
            MessageContentsList is preserved as the IN message body.</p><p><span class="bold"><strong><code class="literal">public Response doAction(InputStream
                abcd);</code></strong></span> The InputStream is unwrapped from the
            MessageContentsList and preserved as the IN message body. </p><p><span class="bold"><strong><code class="literal">public Response doAction(DataHandler
                abcd);</code></strong></span> The DataHandler is unwrapped from the
            MessageContentsList and preserved as the IN message body. </p></div><div class="refsection"><a name="_IDU_CXFRS_HSH_MoreexamplesoftheSimpleBindingStyle"></a><h2>More examples of the Simple Binding Style</h2><p>Given a JAX-RS resource class with this method:</p><pre class="programlisting">
    @POST @Path("/customers/{type}")
    public Response newCustomer(Customer customer, @PathParam("type") String type, @QueryParam("active") @DefaultValue("true") boolean active) {
        return null;
    }
</pre><p>Serviced by the following route:</p><pre class="programlisting">
    from("cxfrs:bean:rsServer?bindingStyle=SimpleConsumer")
        .recipientList(simple("direct:${header.operationName}"));

    from("direct:newCustomer")
        .log("Request: type=${header.type}, active=${header.active}, customerData=${body}");
</pre><p>The following HTTP request with XML payload (given that the Customer DTO is
            JAXB-annotated):</p><pre class="programlisting">
POST /customers/gold?active=true

Payload:
&lt;Customer&gt;
  &lt;fullName&gt;Raul Kripalani&lt;/fullName&gt;
  &lt;country&gt;Spain&lt;/country&gt;
  &lt;project&gt;Apache Camel&lt;/project&gt;
&lt;/Customer&gt;
</pre><p>Will print the message:</p><pre class="programlisting">
Request: type=gold, active=true, customerData=&lt;Customer.toString() representation&gt;
</pre><p>For more examples on how to process requests and write responses can be found <a class="link" href="https://svn.apache.org/repos/asf/camel/trunk/components/camel-cxf/src/test/java/org/apache/camel/component/cxf/jaxrs/simplebinding/" target="_top">here</a>.</p></div><div class="refsection"><a name="_IDU_CXFRS_HSH_ConsumingaRESTRequestDefaultBindingStyle"></a><h2>Consuming a REST Request - Default Binding Style</h2><p>
            <a class="link" href="http://cwiki.apache.org/CXF20DOC/jax-rs.html" target="_top">CXF JAXRS front end</a>
            implements the <a class="link" href="https://jsr311.dev.java.net/" target="_top">JAXRS(JSR311) API</a>, so
            we can export the resources classes as a REST service. And we leverage the <a class="link" href="http://cwiki.apache.org/confluence/display/CXF20DOC/Invokers" target="_top">CXF Invoker
                API</a> to turn a REST request into a normal Java object method invocation.
            Unlike the <code class="literal">camel-restlet</code>, you don't need to specify the URI template
            within your restlet endpoint, CXF take care of the REST request URI to resource class
            method mapping according to the JSR311 specification. All you need to do in Apache Camel is
            delegate this method request to a right processor or endpoint.</p><p>Here is an example of a CXFRS route:</p><pre class="programlisting">private static final String CXF_RS_ENDPOINT_URI = "cxfrs://http://localhost:" + CXT + "/rest?resourceClasses=org.apache.camel.component.cxf.jaxrs.testbean.CustomerServiceResource";
 
 protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder() {
        public void configure() {
            errorHandler(new NoErrorHandlerBuilder());
            from(CXF_RS_ENDPOINT_URI).process(new Processor() {

                public void process(Exchange exchange) throws Exception {
                    Message inMessage = exchange.getIn();                        
                    // Get the operation name from in message
                    String operationName = inMessage.getHeader(CxfConstants.OPERATION_NAME, String.class);
                    if ("getCustomer".equals(operationName)) {
                        String httpMethod = inMessage.getHeader(Exchange.HTTP_METHOD, String.class);
                        assertEquals("Get a wrong http method", "GET", httpMethod);
                        String path = inMessage.getHeader(Exchange.HTTP_PATH, String.class);
                        // The parameter of the invocation is stored in the body of in message
                        String id = inMessage.getBody(String.class);
                        if ("/customerservice/customers/126".equals(path)) {                            
                            Customer customer = new Customer();
                            customer.setId(Long.parseLong(id));
                            customer.setName("Willem");
                            // We just put the response Object into the out message body
                            exchange.getOut().setBody(customer);
                        } else {
                            if ("/customerservice/customers/400".equals(path)) {
                                // We return the remote client IP address this time
                                org.apache.cxf.message.Message cxfMessage = inMessage.getHeader(CxfConstants.CAMEL_CXF_MESSAGE, org.apache.cxf.message.Message.class);
                                ServletRequest request = (ServletRequest) cxfMessage.get("HTTP.REQUEST");
                                String remoteAddress = request.getRemoteAddr();
                                Response r = Response.status(200).entity("The remoteAddress is " + remoteAddress).build();
                                exchange.getOut().setBody(r);
                                return;
                            }
                            if ("/customerservice/customers/123".equals(path)) {
                                 // send a customer response back
                                 Response r = Response.status(200).entity("customer response back!").build();
                                 exchange.getOut().setBody(r);
                                 return;
                            }
                            if ("/customerservice/customers/456".equals(path)) {
                                Response r = Response.status(404).entity("Can't found the customer with uri " + path).build();
                                throw new WebApplicationException(r);
                            } else {
                                throw new RuntimeCamelException("Can't found the customer with uri " + path);
                            }
                        }
                    }
                    if ("updateCustomer".equals(operationName)) {
                        assertEquals("Get a wrong customer message header", "header1;header2", inMessage.getHeader("test"));
                        String httpMethod = inMessage.getHeader(Exchange.HTTP_METHOD, String.class);
                        assertEquals("Get a wrong http method", "PUT", httpMethod);
                        Customer customer = inMessage.getBody(Customer.class);
                        assertNotNull("The customer should not be null.", customer);
                        // Now you can do what you want on the customer object
                        assertEquals("Get a wrong customer name.", "Mary", customer.getName());
                        // set the response back
                        exchange.getOut().setBody(Response.ok().build());
                }
                }
                
            });
        }
    };
}
        </pre><p>The corresponding resource class used to configure the endpoint is defined as an
            interface:</p><pre class="programlisting">@Path("/customerservice/")
public interface CustomerServiceResource {
 
    @GET
    @Path("/customers/{id}/")
    Customer getCustomer(@PathParam("id") String id);
 
    @PUT
    @Path("/customers/")
    Response updateCustomer(Customer customer);
 }
 </pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="imagesdb/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>The resource class is used to configure the JAXRS properties
                    <span class="emphasis"><em>only</em></span>. The methods will <span class="emphasis"><em>not</em></span> be executed
                during the routing of messages to the endpoint, the route itself is responsible for
                all processing instead.</p></td></tr></table></div></div><div class="refsection"><a name="_IDU_CXFRS_HSH_HowtoinvoketheRESTservicethroughcamelcxfrsproducer"></a><h2>How to invoke the REST service through camel-cxfrs producer ?</h2><p>
            <a class="link" href="http://cwiki.apache.org/CXF20DOC/jax-rs.html" target="_top">CXF JAXRS front end</a>
            implements <a class="link" href="http://cwiki.apache.org/CXF20DOC/jax-rs.html#JAX-RS-ProxybasedAPI" target="_top">a proxy
                based client API</a>, with this API you can invoke the remote REST service
            through a proxy. <code class="literal">camel-cxfrs</code> producer is based on this <a class="link" href="http://cwiki.apache.org/CXF20DOC/jax-rs.html#JAX-RS-ProxybasedAPI" target="_top">proxy
                API</a>. So, you just need to specify the operation name in the message header
            and prepare the parameter in the message body, <code class="code">camel-cxfrs</code> producer will
            generate right REST request for you.</p><p>Here is an example</p><pre class="programlisting">Exchange exchange = template.send("direct://proxy", new Processor() {

    public void process(Exchange exchange) throws Exception {
        exchange.setPattern(ExchangePattern.InOut);
        Message inMessage = exchange.getIn();
        setupDestinationURL(inMessage);
        // set the operation name 
        inMessage.setHeader(CxfConstants.OPERATION_NAME, "getCustomer");
        // using the proxy client API
        inMessage.setHeader(CxfConstants.CAMEL_CXF_RS_USING_HTTP_API, Boolean.FALSE);
        // set a customer header
        inMessage.setHeader("key", "value");
        // set the parameters , if you just have one parameter 
        // camel will put this object into an Object[] itself
        inMessage.setBody("123");
    }
    
});
     
// get the response message 
Customer response = (Customer) exchange.getOut().getBody();

assertNotNull("The response should not be null ", response);
assertEquals("Get a wrong customer id ", String.valueOf(response.getId()), "123");
assertEquals("Get a wrong customer name", response.getName(), "John");
assertEquals("Get a wrong response code", 200, exchange.getOut().getHeader(Exchange.HTTP_RESPONSE_CODE));
assertEquals("Get a wrong header value", "value", exchange.getOut().getHeader("key"));</pre><p>
            <a class="link" href="http://cwiki.apache.org/CXF20DOC/jax-rs.html" target="_top">CXF JAXRS front end</a>
            also provides <a class="link" href="http://cxf.apache.org/docs/jax-rs.html#JAX-RS-HTTPcentricclients" target="_top">a http
                centric client API</a>, You can also invoke this API from
                <code class="literal">camel-cxfrs</code> producer. You need to specify the HTTP_PATH and Http
            method and let the the producer know to use the HTTP centric client by using the URI
            option <span class="bold"><strong>httpClientAPI</strong></span> or set the message header with
                <code class="code">CxfConstants.CAMEL_CXF_RS_USING_HTTP_API</code>. You can turn the response
            object to the type class that you specify with
                <code class="code">CxfConstants.CAMEL_CXF_RS_RESPONSE_CLASS</code>.</p><pre class="programlisting">Exchange exchange = template.send("direct://http", new Processor() {

    public void process(Exchange exchange) throws Exception {
        exchange.setPattern(ExchangePattern.InOut);
        Message inMessage = exchange.getIn();
        setupDestinationURL(inMessage);
        // using the http central client API
        inMessage.setHeader(CxfConstants.CAMEL_CXF_RS_USING_HTTP_API, Boolean.TRUE);
        // set the Http method
        inMessage.setHeader(Exchange.HTTP_METHOD, "GET");
        // set the relative path
        inMessage.setHeader(Exchange.HTTP_PATH, "/customerservice/customers/123");                
        // Specify the response class , cxfrs will use InputStream as the response object type 
        inMessage.setHeader(CxfConstants.CAMEL_CXF_RS_RESPONSE_CLASS, Customer.class);
        // set a customer header
        inMessage.setHeader("key", "value");
        // since we use the Get method, so we don't need to set the message body
        inMessage.setBody(null);                
    }
    
});
     
// get the response message 
Customer response = (Customer) exchange.getOut().getBody();

assertNotNull("The response should not be null ", response);
assertEquals("Get a wrong customer id ", String.valueOf(response.getId()), "123");
assertEquals("Get a wrong customer name", response.getName(), "John");
assertEquals("Get a wrong response code", 200, exchange.getOut().getHeader(Exchange.HTTP_RESPONSE_CODE));
assertEquals("Get a wrong header value", "value", exchange.getOut().getHeader("key"));</pre><p>From Apache Camel 2.1, we also support to specify the query parameters from CXFRS URI for
            the CXFRS HTTP centric client.</p><pre class="programlisting">Exchange exchange = template.send("cxfrs://http://localhost:" + getPort2() + "/" + getClass().getSimpleName() + "/testQuery?httpClientAPI=true&amp;q1=12&amp;q2=13"</pre><p> To support the Dynamical routing, you can override the URI's query parameters by
            using the <code class="code">CxfConstants.CAMEL_CXF_RS_QUERY_MAP</code> header to set the parameter
            map for it.</p><pre class="programlisting">Map&lt;String, String&gt; queryMap = new LinkedHashMap&lt;String, String&gt;();                    
queryMap.put("q1", "new");
queryMap.put("q2", "world");                    
inMessage.setHeader(CxfConstants.CAMEL_CXF_RS_QUERY_MAP, queryMap);</pre></div><div class="refsection"><a name="d0e29650"></a><h2>Related topics</h2><table border="0" summary="Simple list" class="simplelist"><tr><td>
                <a class="link" href="http://cxf.apache.org" target="_top">Apache CXF</a>
            </td></tr><tr><td>
                <a class="link" href="http://cxf.apache.org/docs/" target="_top"> Apache CXF Documentation </a>
            </td></tr></table></div></div></body></html>